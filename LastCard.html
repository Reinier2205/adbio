<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Last Card Standing</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">

<style>
/* Core theme variables (matches your suite) */
:root{
  --felt-green:#0a4821;
  --dark-wood:#2a1a1f;
  --gold:#d4af37;
  --gold-light:#ffd700;
  --light-gold:#fff8e1;
  --ivory:#faf8f0;
  --player1-color:#ff6b6b;
  --player2-color:#4ecdc4;
  --player3-color:#ffe66d;
  --player4-color:#a78bfa;
  --card-width:90px;
  --card-height:120px;
}

/* Reset & body */
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:'Lato',sans-serif;
  background: radial-gradient(circle,#4d322e 0%,var(--dark-wood) 70%);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  min-height:100vh;
}

/* Main container (casino table look) */
.table {
  width:100%;
  max-width:1100px;
  background:var(--felt-green);
  background-image: radial-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
                    radial-gradient(rgba(255,255,255,0.06) 1px, var(--felt-green) 1px);
  background-size:4px 4px;
  box-shadow:0 0 0 5px var(--gold), inset 0 0 25px rgba(0,0,0,0.45);
  border-radius:14px;
  padding:20px;
  position:relative;
  overflow:hidden;
}

/* Header */
.header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:12px;
}
.title{
  font-family:'Inter',sans-serif;
  color:var(--gold-light);
  font-weight:700;
  font-size:1.6rem;
  text-shadow:2px 2px 5px rgba(0,0,0,0.7);
}
.controls-top{
  display:flex;
  gap:8px;
  align-items:center;
}

/* Player panels */
.players-row{
  display:flex;
  gap:8px;
  margin-bottom:16px;
  flex-wrap:wrap;
}
.player{
  background:linear-gradient(145deg,#3e1e24,#2a1a1f);
  padding:10px;
  border-radius:8px;
  min-width:170px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:8px;
  border:2px solid rgba(0,0,0,0.6);
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
}
.player .name{
  width:100%;
  text-align:center;
  font-weight:700;
  color:var(--light-gold);
  font-family:'Inter',sans-serif;
}
.player input{
  width:100%;
  padding:6px 8px;
  border-radius:6px;
  border:1px solid rgba(255,255,255,0.06);
  background:rgba(255,255,255,0.03);
  color:var(--light-gold);
  text-align:center;
}

/* Hearts (lives) */
.hearts{display:flex;gap:6px}
.heart{
  width:22px;height:22px;border-radius:6px;
  background:linear-gradient(180deg,var(--gold),#b8860b);
  box-shadow:0 2px 4px rgba(0,0,0,0.5);
  display:flex;align-items:center;justify-content:center;
  color:var(--dark-wood);font-weight:700;font-size:14px;
}
.heart.empty{background:rgba(0,0,0,0.35);color:#666}

/* Game area layout */
.game-area{
  display:flex;
  gap:18px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}

/* Left column: grid & actions */
.left-col{
  flex:1 1 520px;
  min-width:280px;
}

/* Right column: deck, revealed card, status */
.right-col{
  width:260px;
  min-width:220px;
  display:flex;
  flex-direction:column;
  gap:12px;
  align-items:center;
}

/* 3x3 grid styles */
.grid{
  width:100%;
  max-width:520px;
  margin:0 auto 12px;
  display:grid;
  grid-template-columns:repeat(3,1fr);
  gap:12px;
  justify-items:center;
}
.card {
  width:100%;
  max-width:var(--card-width);
  aspect-ratio: 3 / 4;
  height:auto;
  min-height:var(--card-height);
  background:linear-gradient(180deg,var(--ivory),#f1eee6);
  border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-between;
  padding:8px;
  font-family:'Inter',sans-serif;
  cursor:pointer;
  transition:transform .18s ease, box-shadow .18s ease;
  position:relative;
  overflow:visible;
}
.card.placeholder{
  background:linear-gradient(180deg,#0f5a2c,#0a4821);
  color:var(--light-gold);
  border:3px solid rgba(0,0,0,0.6);
  box-shadow: inset 0 0 12px rgba(0,0,0,0.5);
}
.card.selected{ transform:translateY(-6px); box-shadow:0 12px 30px rgba(0,0,0,0.55), 0 0 16px var(--gold-light); }
.card .rank{ font-size:1.2rem; font-weight:700; color:#222;}
.card .suit{ font-size:1.6rem; opacity:0.9; }
.card .small{
  font-size:0.72rem;color:#333;background:rgba(255,255,255,0.4);padding:3px 6px;border-radius:6px;
}

/* Face-down deck visualization */
.deck-visual{
  width:calc(var(--card-width) * .86);
  height:calc(var(--card-height) * .86);
  border-radius:8px;
  background:linear-gradient(180deg,#2b1a1b,#1b0f10);
  border:3px solid #290f10;
  box-shadow:0 8px 20px rgba(0,0,0,0.6), inset 0 0 16px rgba(0,0,0,0.4);
  display:flex;align-items:center;justify-content:center;color:var(--light-gold);
  font-family:'Inter',sans-serif;font-weight:700;
}

/* revealed card slot */
.revealed{
  width:calc(var(--card-width) * 1.06);
  aspect-ratio:3/4;
  border-radius:10px;
  display:flex;align-items:center;justify-content:center;
  background:linear-gradient(180deg,var(--ivory),#f7f5ec);
  box-shadow:0 10px 26px rgba(0,0,0,0.5);
  border:3px solid rgba(0,0,0,0.4);
}

/* action buttons */
.actions{
  display:flex;
  gap:10px;
  margin-top:12px;
  justify-content:center;
  flex-wrap:wrap;
}
.btn{
  font-family:'Inter',sans-serif;
  font-weight:600;
  padding:12px 18px;
  border-radius:8px;
  border:2px solid #111;
  cursor:pointer;
  display:inline-flex;align-items:center;gap:8px;
  box-shadow:0 6px 0 #111, 0 8px 16px rgba(0,0,0,0.45);
  color:white;text-shadow:1px 1px 2px #000;
}
.btn:active{ transform:translateY(3px); box-shadow:0 2px 0 #111; }
.btn-gold{ background:linear-gradient(145deg,var(--gold),#b8860b); color:white; }
.btn-green{ background:linear-gradient(145deg,#008c3a,#005a25) }
.btn-red{ background:linear-gradient(145deg,#a80000,#7b0000) }

/* status & messages */
.status{
  text-align:center;
  color:var(--light-gold);
  font-weight:700;
  font-family:'Inter',sans-serif;
  text-shadow:1px 1px 2px black;
  padding:8px 12px;
  border-radius:8px;
  background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.12));
}

/* small helpers */
.meta { font-size:0.95rem;color:var(--light-gold); }
.counter { font-weight:700; font-family:'Inter',sans-serif; color:var(--gold-light); }

/* modal help */
.modal {
  position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,0.6); z-index:120; opacity:0; visibility:hidden; transition:all 0.2s ease;
}
.modal.show{ opacity:1; visibility:visible; }
.modal-card{
  width:min(880px,95vw); background:linear-gradient(145deg,#3e1e24,#2a1a1f); padding:20px; border-radius:12px; border:3px solid var(--gold);
  color:var(--light-gold); box-shadow:0 16px 60px rgba(0,0,0,0.7);
}
.modal-card h3{ font-family:'Inter',sans-serif; font-size:1.4rem; margin-bottom:10px; color:var(--gold-light) }

/* responsive tweaks */
@media (max-width:900px){
  .game-area { flex-direction:column-reverse; align-items:center; gap:12px }
  .right-col{ width:100%; max-width:520px; display:flex; flex-direction:row; justify-content:space-around; gap:12px; padding:6px 0 }
  .left-col{ width:100% }
  .players-row{ justify-content:center }
}
@media (max-width:440px){
  .player{ min-width:140px }
  :root{ --card-width:68px; --card-height:96px }
}
</style>
</head>
<body>
<div class="table" role="application" aria-label="Last Card Standing game">
  <div class="header">
    <div class="title">Last Card Standing</div>
    <div class="controls-top">
      <label class="meta" for="playerCount">Players</label>
      <select id="playerCount" aria-label="Choose players">
        <option value="1">1</option>
        <option value="2" selected>2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
      <button class="btn btn-gold" id="btnNew">New Game</button>
      <button class="btn" id="btnHelp">Rules</button>
    </div>
  </div>

  <div class="players-row" id="playersRow">
    <!-- player panels injected by script -->
  </div>

  <div class="game-area">
    <div class="left-col">
      <div class="grid" id="grid" aria-label="3 by 3 card grid">
        <!-- 9 card slots -->
      </div>

      <div class="actions" id="actionRow">
        <div class="status" id="turnStatus">Press New Game to start</div>
        <div style="flex-basis:100%"></div>
        <button class="btn btn-green" id="btnHigher" disabled>Higher</button>
        <button class="btn btn-red" id="btnLower" disabled>Lower</button>
      </div>
    </div>

    <div class="right-col">
      <div style="display:flex;flex-direction:column;gap:8px;align-items:center;">
        <div class="meta">Deck</div>
        <div class="deck-visual" id="deckVisual" title="Draw deck">43</div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px;align-items:center;">
        <div class="meta">Revealed</div>
        <div class="revealed" id="revealedSlot">—</div>
      </div>

      <div style="display:flex;flex-direction:column;gap:6px;align-items:center;">
        <div class="meta">Game Log</div>
        <div class="status" id="gameLog" style="min-height:54px">Ready</div>
      </div>
    </div>
  </div>
</div>

<!-- Rules modal -->
<div class="modal" id="modal">
  <div class="modal-card" role="dialog" aria-modal="true">
    <h3>Last Card Standing — Rules</h3>
    <ol style="line-height:1.5;color:var(--light-gold);font-size:0.98rem">
      <li>Shuffle a 52-card deck. Place 9 cards face-up in a 3×3 grid. Remaining cards form the draw deck.</li>
      <li>Players start with 3 lives. First player is chosen randomly.</li>
      <li>On your turn select any grid card and predict <strong>Higher</strong> or <strong>Lower</strong> than that card (A=1, K=13).</li>
      <li>If correct: keep turn, replace selected grid card with the revealed card. If incorrect or tie: lose 1 life and your turn ends.</li>
      <li>If you lose your 3rd life you are eliminated. Last player remaining wins. If the deck runs out after selecting (before reveal), the selecting player wins immediately.</li>
    </ol>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button class="btn" id="closeModal">Close</button>
    </div>
  </div>
</div>

<!-- audio placeholders (add sources later) -->
<!-- <audio id="sndCorrect" src="correct.mp3"></audio>
<audio id="sndWrong" src="wrong.mp3"></audio>
<audio id="sndDeal" src="deal.mp3"></audio> -->

<script>
/*
  Last Card Standing
  - Placeholder styled cards (no images) matching suite
  - 1-4 players, hearts, grid, deck counter
  - Full game logic per rules provided
*/

(() => {
  const suits = ['♠','♥','♦','♣'];
  const ranks = [
    {r:'A', v:1},{r:'2',v:2},{r:'3',v:3},{r:'4',v:4},{r:'5',v:5},
    {r:'6',v:6},{r:'7',v:7},{r:'8',v:8},{r:'9',v:9},{r:'10',v:10},
    {r:'J',v:11},{r:'Q',v:12},{r:'K',v:13}
  ];

  // UI refs
  const gridEl = document.getElementById('grid');
  const playersRow = document.getElementById('playersRow');
  const playerCountSel = document.getElementById('playerCount');
  const btnNew = document.getElementById('btnNew');
  const btnHelp = document.getElementById('btnHelp');
  const modal = document.getElementById('modal');
  const closeModal = document.getElementById('closeModal');
  const deckVisual = document.getElementById('deckVisual');
  const revealedSlot = document.getElementById('revealedSlot');
  const turnStatus = document.getElementById('turnStatus');
  const gameLog = document.getElementById('gameLog');
  const btnHigher = document.getElementById('btnHigher');
  const btnLower = document.getElementById('btnLower');

  // state
  let deck = [];
  let grid = []; // length 9
  let players = []; // {name, lives, eliminated}
  let currentPlayer = 0;
  let selectedIndex = null;
  let inPlay = false;

  // util: create deck, shuffle
  function createDeck(){
    const out = [];
    for(const s of suits){
      for(const r of ranks){
        out.push({suit:s, rank:r.r, value:r.v});
      }
    }
    return out;
  }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  /* UI build */
  function buildPlayers(n){
    playersRow.innerHTML='';
    players = [];
    for(let i=0;i<n;i++){
      const p = document.createElement('div');
      p.className='player';
      p.dataset.index = i;
      p.innerHTML = `
        <div class="name">Player ${i+1}</div>
        <input type="text" aria-label="Player name ${i+1}" placeholder="Player ${i+1}" value="Player ${i+1}" />
        <div class="hearts" aria-hidden="true"></div>
      `;
      playersRow.appendChild(p);
      players.push({name:`Player ${i+1}`, lives:3, eliminated:false});
      // input handler
      const inp = p.querySelector('input');
      inp.addEventListener('input', e=>{
        players[i].name = e.target.value || `Player ${i+1}`;
        p.querySelector('.name').textContent = players[i].name;
      });
    }
    renderHearts();
  }

  function renderHearts(){
    document.querySelectorAll('.player').forEach((el, idx)=>{
      const heartWrap = el.querySelector('.hearts');
      heartWrap.innerHTML = '';
      const life = players[idx].lives;
      for(let i=0;i<3;i++){
        const h = document.createElement('div');
        h.className = 'heart' + (i<life ? '' : ' empty');
        h.innerHTML = i<life ? '❤' : '✖';
        heartWrap.appendChild(h);
      }
      if(players[idx].eliminated){
        el.style.opacity = 0.45;
        el.style.transform = 'scale(.98)';
      } else {
        el.style.opacity = 1;
        el.style.transform = 'none';
      }
    });
  }

  /* grid rendering */
  function buildGrid(){
    gridEl.innerHTML = '';
    for(let i=0;i<9;i++){
      const slot = document.createElement('div');
      slot.className = 'card placeholder';
      slot.dataset.index = i;
      slot.setAttribute('role','button');
      slot.setAttribute('tabindex','0');
      slot.innerHTML = `<div class="small">Empty</div>`;
      slot.addEventListener('click', ()=> onSelectIndex(i));
      slot.addEventListener('keydown', e=>{ if(e.key === 'Enter') onSelectIndex(i) });
      gridEl.appendChild(slot);
    }
  }

  function renderGrid(){
    // grid items show rank & suit
    const slots = gridEl.children;
    for(let i=0;i<9;i++){
      const card = grid[i];
      const slot = slots[i];
      slot.classList.remove('selected');
      if(card){
        slot.classList.remove('placeholder');
        slot.innerHTML = `
          <div style="align-self:flex-start;color:#222;font-weight:700">${card.rank}</div>
          <div class="suit" style="font-size:1.6rem">${card.suit}</div>
          <div class="small" style="align-self:flex-end;background:transparent">${card.value}</div>
        `;
      } else {
        slot.classList.add('placeholder');
        slot.innerHTML = `<div class="small">Empty</div>`;
      }
      // disabled state
      if(!inPlay) slot.style.pointerEvents = 'none';
      else slot.style.pointerEvents = 'auto';
    }
  }

  /* Start new game */
  function newGame(){
    // get player count
    const pc = parseInt(playerCountSel.value,10);
    buildPlayers(pc);
    buildGrid();
    // build deck and deal 9 face-up
    deck = shuffle(createDeck());
    grid = [];
    for(let i=0;i<9;i++){
      grid.push(deck.pop()); // face-up to grid
    }
    // reset players
    players.forEach(p=>{ p.lives=3; p.eliminated=false; });
    currentPlayer = Math.floor(Math.random()*players.length);
    selectedIndex = null;
    inPlay = true;
    revealedSlot.innerHTML = '—';
    updateDeckVisual();
    renderGrid();
    renderHearts();
    log(`Game started. ${players[currentPlayer].name} goes first.`);
    turnStatus.textContent = `${players[currentPlayer].name}'s turn`;
    startDealAnimation().then(()=>{
      enableSelection(true);
    });
  }

  /* Deal animation: flip cards in sequence */
  function startDealAnimation(){
    // animate placeholder -> flip to show content
    const slots = gridEl.children;
    return new Promise(resolve=>{
      let i=0;
      const iv = setInterval(()=>{
        if(i>=slots.length){ clearInterval(iv); resolve(); return; }
        const slot = slots[i];
        slot.style.transition = 'transform .22s ease';
        slot.style.transform = 'translateY(-12px) rotateX(12deg)';
        setTimeout(()=> {
          slot.style.transform = 'none';
        }, 220);
        i++;
      }, 100);
    });
  }

  /* UI helpers */
  function updateDeckVisual(){
    deckVisual.textContent = deck.length;
  }
  function log(msg){
    gameLog.textContent = msg;
  }

  /* Selection flow */
  function onSelectIndex(i){
    if(!inPlay) return;
    if(players[currentPlayer].eliminated) return;
    // select cell
    if(selectedIndex !== null){
      const prev = gridEl.querySelector(`.card[data-index="${selectedIndex}"]`);
      if(prev) prev.classList.remove('selected');
    }
    selectedIndex = i;
    const el = gridEl.querySelector(`.card[data-index="${i}"]`);
    if(el) el.classList.add('selected');
    // enable guess buttons
    btnHigher.disabled = false;
    btnLower.disabled = false;
    log(`${players[currentPlayer].name} selected card ${grid[i].rank}${grid[i].suit}. Choose Higher or Lower.`);
  }

  /* Draw and reveal card (with deck-empty rule) */
  function drawCard(){
    // deck empty: per rules -> if deck empty during player's turn AFTER they select (before reveal), that player wins immediately
    if(deck.length === 0){
      endGameWithWinner(currentPlayer, 'Deck exhausted during selection — instant win!');
      return null;
    }
    const card = deck.pop();
    updateDeckVisual();
    return card;
  }

  /* Resolve guess */
  function resolveGuess(guess){ // guess: 'higher' or 'lower'
    if(selectedIndex === null) return;
    disableGuesses();
    const baseCard = grid[selectedIndex];
    if(!baseCard){
      log('Invalid selection');
      return;
    }
    // draw card
    const drawn = drawCard();
    if(drawn === null) return; // deck exhaustion handled
    // animate reveal
    revealedSlot.innerHTML = `
      <div style="text-align:center">
        <div style="font-weight:700;color:#222">${drawn.rank}</div>
        <div style="font-size:1.6rem">${drawn.suit}</div>
        <div style="font-size:0.8rem;color:#444">(${drawn.value})</div>
      </div>
    `;
    // small delay to let player see card
    setTimeout(()=>{
      const correct = (guess === 'higher' && drawn.value > baseCard.value) || (guess === 'lower' && drawn.value < baseCard.value);
      if(correct){
        // correct: replace grid card with revealed card, keep turn
        grid[selectedIndex] = drawn;
        renderGrid();
        renderHearts();
        log(`${players[currentPlayer].name} guessed correctly and keeps the turn.`);
        // sound placeholder: correct
        // document.getElementById('sndCorrect')?.play();
        // check win-by-elimination (if only one player not eliminated) handled elsewhere
        // if deck empty after draw, game continues until deck exhaustion rule triggers on next selection
        // keep currentPlayer
        // clear selection so player must select again
        const prevSlot = gridEl.querySelector(`.card[data-index="${selectedIndex}"]`);
        if(prevSlot) prevSlot.classList.remove('selected');
        selectedIndex = null;
        enableSelection(true);
        turnStatus.textContent = `${players[currentPlayer].name} (keep playing)`;
      } else {
        // incorrect (includes ties)
        players[currentPlayer].lives -= 1;
        // sound placeholder: wrong
        // document.getElementById('sndWrong')?.play();
        if(players[currentPlayer].lives <= 0){
          players[currentPlayer].eliminated = true;
          log(`${players[currentPlayer].name} guessed wrong and is eliminated.`);
        } else {
          log(`${players[currentPlayer].name} guessed wrong and loses a life.`);
        }
        renderHearts();
        // end turn -> advance to next active player
        advanceTurn();
      }
      checkForSingleWinner();
    }, 420);
  }

  /* Turn advancement */
  function advanceTurn(){
    // find next non-eliminated player
    if(checkForSingleWinner()) return;
    let next = currentPlayer;
    const n = players.length;
    for(let i=1;i<=n;i++){
      const idx = (currentPlayer + i) % n;
      if(!players[idx].eliminated){
        next = idx;
        break;
      }
    }
    currentPlayer = next;
    selectedIndex = null;
    revealedSlot.innerHTML = '—';
    turnStatus.textContent = `${players[currentPlayer].name}'s turn`;
    enableSelection(true);
  }

  /* Enable/disable selection and guess buttons */
  function enableSelection(enable){
    inPlay = enable;
    const slots = gridEl.children;
    for(let i=0;i<slots.length;i++){
      const slot = slots[i];
      slot.style.pointerEvents = enable ? 'auto' : 'none';
      slot.setAttribute('aria-disabled', String(!enable));
    }
    btnHigher.disabled = true;
    btnLower.disabled = true;
  }
  function disableGuesses(){
    btnHigher.disabled = true;
    btnLower.disabled = true;
  }

  /* Check for winner when only one player left */
  function checkForSingleWinner(){
    const active = players.filter(p=>!p.eliminated);
    if(active.length === 1){
      const idx = players.findIndex(p=>!p.eliminated);
      endGameWithWinner(idx, `${players[idx].name} is the last player standing!`);
      return true;
    }
    // if all eliminated (rare), no one wins
    if(active.length === 0){
      endGameWithWinner(null, 'All players eliminated. No winner.');
      return true;
    }
    return false;
  }

  function endGameWithWinner(idx, message){
    inPlay = false;
    enableSelection(false);
    if(idx === null){
      turnStatus.textContent = 'Game over';
      log(message);
      alert(message);
    } else {
      turnStatus.textContent = `${players[idx].name} wins!`;
      log(message);
      // confetti placeholder - you can integrate later
      setTimeout(()=> alert(`${players[idx].name} wins!\n\n${message}`), 80);
    }
  }

  /* Event bindings */
  btnNew.addEventListener('click', ()=> {
    newGame();
  });
  btnHelp.addEventListener('click', ()=> modal.classList.add('show'));
  closeModal.addEventListener('click', ()=> modal.classList.remove('show'));
  modal.addEventListener('click', e=> { if(e.target === modal) modal.classList.remove('show') });

  btnHigher.addEventListener('click', ()=> {
    if(selectedIndex===null) { log('Select a grid card first'); return; }
    resolveGuess('higher');
  });
  btnLower.addEventListener('click', ()=> {
    if(selectedIndex===null) { log('Select a grid card first'); return; }
    resolveGuess('lower');
  });

  // Select cell from grid (public to allow direct calls)
  window.onSelectIndex = onSelectIndex;

  // initial build
  buildPlayers(parseInt(playerCountSel.value,10));
  buildGrid();
  updateDeckVisual();
  renderGrid();

  // change player count resets UI but not game
  playerCountSel.addEventListener('change', ()=> {
    buildPlayers(parseInt(playerCountSel.value,10));
  });

  // keyboard accessibility shortcuts
  document.addEventListener('keydown', e=>{
    if(e.key === 'h' || e.key === 'H') btnHigher.click();
    if(e.key === 'l' || e.key === 'L') btnLower.click();
  });

  // small helper: check deck run-out immediate win scenario when selecting a grid card
  // We already handle this inside drawCard() — deck length checked during draw before reveal.

})();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Last Card Standing</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">

<style>
:root{
  --felt-green:#0a4821;
  --dark-wood:#2a1a1f;
  --gold:#d4af37;
  --gold-light:#ffd700;
  --light-gold:#fff8e1;
  --ivory:#faf8f0;
  --card-width:90px;
  --card-height:120px;
}
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:'Lato',sans-serif;
  background: radial-gradient(circle,#4d322e 0%,var(--dark-wood) 70%);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  min-height:100vh;
}
.table {
  width:100%;
  max-width:1100px;
  background:var(--felt-green);
  background-image: radial-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
                    radial-gradient(rgba(255,255,255,0.06) 1px, var(--felt-green) 1px);
  background-size:4px 4px;
  box-shadow:0 0 0 5px var(--gold), inset 0 0 25px rgba(0,0,0,0.45);
  border-radius:14px;
  padding:20px;
  position:relative;
}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;}
.title{font-family:'Inter',sans-serif;color:var(--gold-light);font-weight:700;font-size:1.6rem;text-shadow:2px 2px 5px rgba(0,0,0,0.7);}
.controls-top{display:flex;gap:8px;align-items:center;}
.players-row{display:flex;gap:8px;margin-top:16px;flex-wrap:wrap;justify-content:center;}
.player{
  background:linear-gradient(145deg,#3e1e24,#2a1a1f);
  padding:8px 10px;
  border-radius:8px;
  min-width:150px;
  display:flex;flex-direction:row;align-items:center;justify-content:space-between;gap:6px;
  border:2px solid rgba(0,0,0,0.6);
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.5);
  height:48px;
  transition:all .2s ease;
}
.player .name{font-weight:700;color:var(--light-gold);font-family:'Inter',sans-serif;font-size:1rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.edit-name-icon{cursor:pointer;font-size:1rem;color:var(--gold);margin-left:6px;transition:transform .2s;}
.edit-name-icon:hover{transform:scale(1.2)}
.hearts{display:flex;gap:4px;margin-left:auto}
.heart{width:18px;height:18px;border-radius:4px;background:linear-gradient(180deg,var(--gold),#b8860b);box-shadow:0 1px 3px rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;color:var(--dark-wood);font-weight:700;font-size:12px;}
.heart.empty{background:rgba(0,0,0,0.35);color:#666}
.player.active{border-color:var(--gold);transform:scale(1.05);box-shadow:0 0 16px var(--gold-light), inset 0 2px 6px rgba(0,0,0,0.5);}
.game-area{display:flex;gap:18px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;}
.left-col{flex:1 1 520px;min-width:280px;}
.right-col{width:260px;min-width:220px;display:flex;flex-direction:column;gap:12px;align-items:center;}
.grid{width:100%;max-width:520px;margin:0 auto 12px;display:grid;grid-template-columns:repeat(3,1fr);gap:12px;justify-items:center;}
.card{width:100%;max-width:var(--card-width);aspect-ratio:3/4;min-height:var(--card-height);background:linear-gradient(180deg,var(--ivory),#f1eee6);border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.6);display:flex;flex-direction:column;align-items:center;justify-content:space-between;padding:8px;font-family:'Inter',sans-serif;cursor:pointer;transition:transform .18s ease, box-shadow .18s ease;}
.card.placeholder{background:linear-gradient(180deg,#0f5a2c,#0a4821);color:var(--light-gold);border:3px solid rgba(0,0,0,0.6);box-shadow: inset 0 0 12px rgba(0,0,0,0.5);}
.card.selected{transform:translateY(-6px);box-shadow:0 12px 30px rgba(0,0,0,0.55), 0 0 16px var(--gold-light);}
.deck-visual{width:calc(var(--card-width)*.86);height:calc(var(--card-height)*.86);border-radius:8px;background:linear-gradient(180deg,#2b1a1b,#1b0f10);border:3px solid #290f10;box-shadow:0 8px 20px rgba(0,0,0,0.6), inset 0 0 16px rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;color:var(--light-gold);font-family:'Inter',sans-serif;font-weight:700;}
.revealed{width:calc(var(--card-width)*1.06);aspect-ratio:3/4;border-radius:10px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--ivory),#f7f5ec);box-shadow:0 10px 26px rgba(0,0,0,0.5);border:3px solid rgba(0,0,0,0.4);}
.actions{display:flex;justify-content:center;gap:20px;margin-bottom:16px;}
.btn{font-family:'Inter',sans-serif;font-weight:600;padding:12px 18px;border-radius:8px;border:2px solid #111;cursor:pointer;display:inline-flex;align-items:center;gap:8px;box-shadow:0 6px 0 #111,0 8px 16px rgba(0,0,0,0.45);color:white;text-shadow:1px 1px 2px #000;}
.btn:active{transform:translateY(3px);box-shadow:0 2px 0 #111;}
.btn-green{background:linear-gradient(145deg,#008c3a,#005a25)}
.btn-red{background:linear-gradient(145deg,#a80000,#7b0000)}
.big-btn{font-size:1.4rem;padding:18px 32px;}
.status{text-align:center;color:var(--light-gold);font-weight:700;font-family:'Inter',sans-serif;text-shadow:1px 1px 2px black;padding:8px 12px;border-radius:8px;background:linear-gradient(180deg,rgba(0,0,0,0.2),rgba(0,0,0,0.12));}
.meta{font-size:0.95rem;color:var(--light-gold);}

/* Winner modal */
#winnerModal{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:9999;
}
.winner-box{
  background:var(--felt-green);
  border:4px solid var(--gold);
  border-radius:14px;
  padding:30px;
  text-align:center;
  box-shadow:0 0 30px var(--gold-light);
  max-width:400px;
}
.winner-box h2{font-family:'Inter',sans-serif;font-size:1.8rem;color:var(--gold-light);margin-bottom:12px;text-shadow:0 0 10px black;}
.winner-box p{color:var(--light-gold);margin-bottom:20px;}
.winner-box button{background:linear-gradient(145deg,#008c3a,#005a25);color:white;border:none;padding:12px 20px;border-radius:8px;font-size:1rem;font-weight:700;cursor:pointer;}
</style>
</head>
<body>
<div class="table">
  <div class="header">
    <div class="title">Last Card Standing</div>
    <div class="controls-top">
      <label class="meta" for="playerCount">Players</label>
      <select id="playerCount"><option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option></select>
      <button class="btn btn-green" id="btnNew">New Game</button>
      <button class="btn" id="btnHelp">Rules</button>
    </div>
  </div>
  <div class="actions"><button class="btn btn-green big-btn" id="btnHigher" disabled>HIGHER</button><button class="btn btn-red big-btn" id="btnLower" disabled>LOWER</button></div>
  <div class="game-area">
    <div class="left-col"><div class="grid" id="grid"></div></div>
    <div class="right-col">
      <div><div class="meta">Deck</div><div class="deck-visual" id="deckVisual">43</div></div>
      <div><div class="meta">Revealed</div><div class="revealed" id="revealedSlot">—</div></div>
      <div><div class="meta">Game Log</div><div class="status" id="gameLog">Ready</div></div>
    </div>
  </div>
  <div class="players-row" id="playersRow"></div>
</div>

<div id="winnerModal"><div class="winner-box"><h2 id="winnerTitle">Winner!</h2><p id="winnerMessage"></p><button onclick="location.reload()">Play Again</button></div></div>

<script>
function launchConfetti(){
  const duration=2000,end=Date.now()+duration;
  (function frame(){
    const colors=['#ffd700','#d4af37','#fff8e1','#ff6b6b','#4ecdc4','#ffe66d'];
    const particle=document.createElement('div');
    particle.style.position='fixed';particle.style.width='8px';particle.style.height='8px';
    particle.style.background=colors[Math.floor(Math.random()*colors.length)];
    particle.style.top='0px';particle.style.left=Math.random()*window.innerWidth+'px';
    particle.style.opacity=1;particle.style.pointerEvents='none';particle.style.zIndex=99999;
    document.body.appendChild(particle);
    const fall=Math.random()*window.innerHeight;
    particle.animate([{transform:`translateY(${fall}px)`,opacity:1},{opacity:0}],{duration:2000,iterations:1});
    setTimeout(()=>particle.remove(),2000);
    if(Date.now()<end)requestAnimationFrame(frame);
  })();
}

(() => {
  const suits=['♠','♥','♦','♣'];
  const ranks=[{r:'A',v:1},{r:'2',v:2},{r:'3',v:3},{r:'4',v:4},{r:'5',v:5},{r:'6',v:6},{r:'7',v:7},{r:'8',v:8},{r:'9',v:9},{r:'10',v:10},{r:'J',v:11},{r:'Q',v:12},{r:'K',v:13}];
  const gridEl=document.getElementById('grid'),playersRow=document.getElementById('playersRow'),playerCountSel=document.getElementById('playerCount');
  const btnNew=document.getElementById('btnNew'),btnHigher=document.getElementById('btnHigher'),btnLower=document.getElementById('btnLower');
  const deckVisual=document.getElementById('deckVisual'),revealedSlot=document.getElementById('revealedSlot'),gameLog=document.getElementById('gameLog');
  let deck=[],grid=[],players=[],currentPlayer=0,selectedIndex=null,inPlay=false;

  function createDeck(){let out=[];for(const s of suits){for(const r of ranks){out.push({suit:s,rank:r.r,value:r.v});}}return out;}
  function shuffle(arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;}
  function buildPlayers(n){playersRow.innerHTML='';players=[];for(let i=0;i<n;i++){const p=document.createElement('div');p.className='player';p.dataset.index=i;p.innerHTML=`<div class="name">Player ${i+1}</div><span class="edit-name-icon">✎</span><div class="hearts"></div>`;playersRow.appendChild(p);players.push({name:`Player ${i+1}`,lives:3,eliminated:false});p.querySelector('.edit-name-icon').addEventListener('click',()=>{const newName=prompt("Enter new name",players[i].name);if(newName){players[i].name=newName;p.querySelector('.name').textContent=newName;}});}renderHearts();highlightActive();}
  function renderHearts(){document.querySelectorAll('.player').forEach((el,idx)=>{const hwrap=el.querySelector('.hearts');hwrap.innerHTML='';for(let i=0;i<3;i++){const h=document.createElement('div');h.className='heart'+(i<players[idx].lives?'':' empty');h.textContent=i<players[idx].lives?'❤':'✖';hwrap.appendChild(h);}el.style.opacity=players[idx].eliminated?0.45:1;});}
  function highlightActive(){document.querySelectorAll('.player').forEach((el,idx)=>{if(idx===currentPlayer&&!players[idx].eliminated){el.classList.add('active');}else{el.classList.remove('active');}});}
  function buildGrid(){gridEl.innerHTML='';grid=[];for(let i=0;i<9;i++){const slot=document.createElement('div');slot.className='card placeholder';slot.dataset.index=i;slot.textContent="Empty";slot.addEventListener('click',()=>onSelectIndex(i));gridEl.appendChild(slot);grid.push(null);}}
  function renderGrid(){[...gridEl.children].forEach((slot,i)=>{const card=grid[i];slot.classList.remove('selected');if(card){slot.classList.remove('placeholder');slot.innerHTML=`<div>${card.rank}</div><div style="font-size:1.6rem">${card.suit}</div><div>${card.value}</div>`;}else{slot.classList.add('placeholder');slot.textContent="Empty";}slot.style.pointerEvents=inPlay?'auto':'none';});}
  function newGame(){const pc=parseInt(playerCountSel.value,10);buildPlayers(pc);buildGrid();deck=shuffle(createDeck());for(let i=0;i<9;i++){grid[i]=deck.pop();}players.forEach(p=>{p.lives=3;p.eliminated=false;});currentPlayer=Math.floor(Math.random()*players.length);selectedIndex=null;inPlay=true;revealedSlot.textContent='—';updateDeckVisual();renderGrid();renderHearts();highlightActive();gameLog.textContent=`Game started. ${players[currentPlayer].name} goes first.`;}
  function updateDeckVisual(){deckVisual.textContent=deck.length;}
  function onSelectIndex(i){if(!inPlay||players[currentPlayer].eliminated)return;selectedIndex=i;document.querySelectorAll('.card').forEach(c=>c.classList.remove('selected'));gridEl.children[i].classList.add('selected');btnHigher.disabled=false;btnLower.disabled=false;}
  function drawCard(){if(deck.length===0){endGameWithWinner(currentPlayer,"Deck exhausted — instant win!");return null;}const c=deck.pop();updateDeckVisual();return c;}
  function resolveGuess(guess){if(selectedIndex===null)return;btnHigher.disabled=true;btnLower.disabled=true;const base=grid[selectedIndex];const drawn=drawCard();if(!drawn)return;revealedSlot.innerHTML=`<div><div>${drawn.rank}</div><div style="font-size:1.6rem">${drawn.suit}</div><div>${drawn.value}</div></div>`;setTimeout(()=>{const correct=(guess==='higher'&&drawn.value>base.value)||(guess==='lower'&&drawn.value<base.value);if(correct){grid[selectedIndex]=drawn;renderGrid();gameLog.textContent=`${players[currentPlayer].name} guessed correctly.`;selectedIndex=null;}else{players[currentPlayer].lives--;if(players[currentPlayer].lives<=0){players[currentPlayer].eliminated=true;gameLog.textContent=`${players[currentPlayer].name} is eliminated.`;}else{gameLog.textContent=`${players[currentPlayer].name} guessed wrong.`;}renderHearts();advanceTurn();}highlightActive();checkForSingleWinner();},400);}
  function advanceTurn(){let n=players.length;for(let i=1;i<=n;i++){const idx=(currentPlayer+i)%n;if(!players[idx].eliminated){currentPlayer=idx;break;}}selectedIndex=null;revealedSlot.textContent='—';btnHigher.disabled=true;btnLower.disabled=true;gameLog.textContent=`${players[currentPlayer].name}'s turn.`;highlightActive();}
  function checkForSingleWinner(){const active=players.filter(p=>!p.eliminated);if(active.length===1){const idx=players.findIndex(p=>!p.eliminated);endGameWithWinner(idx,`${players[idx].name} wins!`);return true;}return false;}
  function endGameWithWinner(idx,msg){inPlay=false;btnHigher.disabled=true;btnLower.disabled=true;highlightActive();gameLog.textContent=msg;document.getElementById('winnerTitle').textContent="Last Card Standing";document.getElementById('winnerMessage').textContent=msg;document.getElementById('winnerModal').style.display='flex';launchConfetti();}
  btnNew.addEventListener('click',newGame);btnHigher.addEventListener('click',()=>resolveGuess('higher'));btnLower.addEventListener('click',()=>resolveGuess('lower'));document.getElementById('btnHelp').addEventListener('click',()=>{alert(`🃏 Last Card Standing Rules\n\nGoal: Be the last player with lives remaining.\n\nSetup: 9 cards in grid, rest in deck. 3 lives each.\n\nTurn: Pick grid card, guess higher/lower, reveal top card.\nCorrect: replace grid card, go again. Wrong: lose life, next player.\nEliminated at 0 lives.\nLast player standing or deck exhaustion wins.`);});newGame();
})();
</script>
</body>
</html>
