<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Hobak Gonu (Five Stone Gonu)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
<style>
:root{
  --felt-green:#0a4821;
  --dark-wood:#2a1a1f;
  --gold:#d4af37;
  --gold-light:#ffd700;
  --light-gold:#fff8e1;
  --yellow-piece:#f9d924;
  --red-piece:#d13535;
  --piece-size: 30px;
}
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:'Lato',sans-serif;
  background: radial-gradient(circle,#4d322e 0%,var(--dark-wood) 70%);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:20px 10px; 
  min-height:100vh;
}
.table {
  width:100%;
  max-width:600px;
  background:var(--felt-green);
  background-image: radial-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
                    radial-gradient(rgba(255,255,255,0.06) 1px, var(--felt-green) 1px);
  background-size:4px 4px;
  box-shadow:0 0 0 5px var(--gold), inset 0 0 25px rgba(0,0,0,0.45);
  border-radius:14px;
  padding:16px; 
  position:relative;
}
.header{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:12px;
  margin-bottom:12px;
}
.title{
  font-family:'Inter',sans-serif;
  color:var(--gold-light);
  font-weight:700;
  font-size:1.6rem;
  text-shadow:2px 2px 5px rgba(0,0,0,0.7);
  text-align:center;
}
/* Removed status-bar (game log) CSS */

.controls-bottom{
  display:flex;
  justify-content:center;
  gap:10px;
  margin-top:16px;
}
.btn{
  font-family:'Inter',sans-serif;
  font-weight:600;
  padding:10px 16px;
  border-radius:8px;
  border:2px solid #111;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:8px;
  box-shadow:0 6px 0 #111,0 8px 16px rgba(0,0,0,0.45);
  color:white;
  text-shadow:1px 1px 2px #000;
  transition:transform .1s, box-shadow .1s;
}
.btn:active{transform:translateY(3px);box-shadow:0 2px 0 #111;}
.btn-green{background:linear-gradient(145deg,#008c3a,#005a25)}
.btn-gold{background:linear-gradient(145deg,var(--gold-light),var(--gold)); color:var(--dark-wood); text-shadow:none;}

/* --- Board Styling --- */
.board-container{
  position:relative;
  width:100%;
  max-width:400px;
  aspect-ratio:1/1;
  margin:20px auto 0;
}
.board-svg{
  width:100%;
  height:100%;
  position:relative;
  z-index:1;
}
/* THINNER LINES */
.board-svg line, .board-svg circle{
  stroke:#fff;
  stroke-width:1.5; 
  stroke-linecap:round;
  filter:drop-shadow(1px 1px 2px rgba(0,0,0,0.8));
}
.board-svg circle{
    fill: none;
}
.node{
  position:absolute;
  width:var(--piece-size);height:var(--piece-size);
  border-radius:50%;
  background-color:transparent;
  border:2px solid transparent; 
  cursor:pointer;
  transition:transform .15s, box-shadow .15s, background-color .15s;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:0; 
  color:transparent;
  z-index:10;
}

/* 3. REMOVE ALL LETTER LABELS */
.node::after {
    content: none !important; 
}

/* Lighter border for occupied node (removed below, keeping this here for context) */
.node.occupied{cursor:pointer;border:none;}

/* HOVER STATE FOR EMPTY NODES - adds a slight visual cue */
.node:hover:not(.occupied):not(.disabled):not(.selectable){
  transform:scale(1.1);
  box-shadow:0 0 8px rgba(255,255,255,0.4);
  background-color: rgba(255, 255, 255, 0.1);
}

/* Piece Colors - SHINY 3D LOOK, NO BORDERS */
.node.occupied {
    border: none !important;
    cursor: pointer;
    /* Common 3D/Shadow effect */
    box-shadow: 
        inset 0 0 10px rgba(255, 255, 255, 0.5), /* inner highlight */
        0 5px 10px rgba(0, 0, 0, 0.6), /* strong bottom shadow */
        0 0 15px rgba(255, 255, 255, 0.1) inset; /* ambient shine */
}

/* --- CONSISTENT, SOLID, SHINY TOKENS --- */
.token-gradient {
    /* Base style for the shiny, solid look */
    background: radial-gradient(circle at 25% 25%, #ffffff 0%, var(--token-color) 60%, var(--token-dark) 100%);
}
.node.yellow{
  /* Shiny Gradient - Using #ffffff for maximum solid highlight */
  background: radial-gradient(circle at 25% 25%, #ffffff 0%, var(--yellow-piece) 60%, #c4a71c 100%);
  color:var(--dark-wood);
}
.node.red{
  /* Shiny Gradient - Using #ffffff for maximum solid highlight */
  background: radial-gradient(circle at 25% 25%, #ffffff 0%, var(--red-piece) 60%, #a32727 100%);
  color:white;
}
/* ----------------------------------------------------------------- */


/* Interaction States */
.node.current-piece{
  transform:scale(1.2);
  box-shadow: 
    0 0 15px var(--gold-light),
    inset 0 0 10px rgba(255, 255, 255, 0.8), /* inner highlight */
    0 5px 10px rgba(0, 0, 0, 0.8); /* stronger shadow when selected */
}
.node.target-move{
  /* Target highlight is now just a pulsing ring */
  background-color:transparent !important;
  border:2px solid var(--gold-light) !important;
  box-shadow:0 0 10px var(--gold-light);
  animation: pulse 1s infinite alternate;
}
.node.target-move:hover{
  transform:scale(1.25);
}

@keyframes pulse {
    from {box-shadow:0 0 10px var(--gold-light), inset 0 0 5px var(--gold); }
    to {box-shadow:0 0 20px var(--gold-light), inset 0 0 8px var(--gold); }
}

.node.disabled{cursor:default;opacity:0.7;}

/* Player Indicators */
.player-info {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin-top: 10px;
    background: rgba(0,0,0,0.1);
    border-radius: 8px;
}
.player-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 15px;
    border-radius: 6px;
    border: 2px solid transparent;
    transition: all 0.3s;
}
.player-card.active {
    border-color: var(--gold);
    background: rgba(255,255,255,0.05);
    box-shadow: 0 0 10px rgba(255,255,0,0.5);
}
.piece-display {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    margin-bottom: 5px;
    /* Updated 3D styling to be consistent with main pieces */
    box-shadow: 
        inset 0 0 8px rgba(255, 255, 255, 0.6), /* inner highlight */
        0 3px 8px rgba(0, 0, 0, 0.6), /* bottom shadow */
        inset 0 0 10px rgba(255, 255, 255, 0.1); /* ambient shine */
}
/* --- CONSISTENT, SOLID, SHINY TOKENS FOR INDICATORS (Borders Removed) --- */
.piece-display.yellow { 
    background: radial-gradient(circle at 25% 25%, #ffffff 0%, var(--yellow-piece) 60%, #c4a71c 100%);
    /* Removed border: 2px solid var(--gold); */
}
.piece-display.red { 
    background: radial-gradient(circle at 25% 25%, #ffffff 0%, var(--red-piece) 60%, #a32727 100%);
    /* Removed border: 2px solid white; */
}
/* ----------------------------------------------------------------------------- */
.player-name {
    color: var(--light-gold);
    font-weight: 700;
    font-size: 1.1rem;
}

/* Modal */
#modal{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:9999;
}
.modal-box{
  background:linear-gradient(145deg, #2a1a1f, var(--dark-wood));
  border:4px solid var(--gold);
  border-radius:14px;
  padding:30px;
  text-align:center;
  box-shadow:0 0 30px var(--gold-light);
  max-width:400px;
}
.modal-box h2{font-family:'Inter',sans-serif;font-size:1.8rem;color:var(--gold-light);margin-bottom:12px;text-shadow:0 0 10px black;}
.modal-box p{color:var(--light-gold);margin-bottom:20px;}
.modal-box button{background:linear-gradient(145deg,#008c3a,#005a25);color:white;border:none;padding:12px 20px;border-radius:8px;font-size:1rem;font-weight:700;cursor:pointer;}

</style>
</head>
<body>
<div class="table">
  <div class="header">
    <div class="title">Hobak Gonu</div>
    <!-- Removed status-bar/gameLog div -->
  </div>

  <!-- Player Info -->
  <div class="player-info">
    <div class="player-card" data-player="P1" id="player1Card">
        <div class="piece-display yellow"></div>
        <div class="player-name">Player 1 (Yellow)</div>
    </div>
    <div class="player-card" data-player="P2" id="player2Card">
        <div class="piece-display red"></div>
        <div class="player-name">Player 2 (Red)</div>
    </div>
  </div>

  <!-- Board -->
  <div class="board-container" id="boardContainer">
    <!-- SVG for Lines. Using (0,0) to (100,100) coordinate system. -->
    <svg class="board-svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
        <!-- Center Circle (Radius 30, centered at 50,50) -->
        <circle cx="50" cy="50" r="30" /> 

        <!-- Vertical Cross Line (D-E-F) -->
        <line x1="50" y1="10" x2="50" y2="90" /> 

        <!-- Left Vertical Line (A-B-C) - Positioned at X=0 -->
        <line x1="0" y1="10" x2="0" y2="90" />
        
        <!-- Right Vertical Line (G-H-I) - Positioned at X=100 -->
        <line x1="100" y1="10" x2="100" y2="90" />

        <!-- Horizontal Connecting Lines - Segmented for J (20,50) and K (80,50) -->
        
        <!-- B (0,50) to J (20,50) -->
        <line x1="0" y1="50" x2="20" y2="50" /> 
        <!-- J (20,50) to E (50,50) -->
        <line x1="20" y1="50" x2="50" y2="50" /> 
        
        <!-- H (100,50) to K (80,50) -->
        <line x1="100" y1="50" x2="80" y2="50" />
        <!-- K (80,50) to E (50,50) -->
        <line x1="80" y1="50" x2="50" y2="50" /> 
    </svg>
    
    <!-- Nodes (A-I, J, K) -->
    
    <!-- Left Line Nodes (X=0%) -->
    <div class="node" id="A" data-node="A" style="left: calc(0% - var(--piece-size) / 2); top: calc(10% - var(--piece-size) / 2);">A</div> 
    <div class="node" id="B" data-node="B" style="left: calc(0% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">B</div> 
    <div class="node" id="C" data-node="C" style="left: calc(0% - var(--piece-size) / 2); top: calc(90% - var(--piece-size) / 2);">C</div> 
    
    <!-- J Node (X=20%) -->
    <div class="node" id="J" data-node="J" style="left: calc(20% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">J</div>

    <!-- Center Cross Nodes (X=50%) -->
    <!-- D: Updated from 10% to 20% to align with inner circle intersection -->
    <div class="node" id="D" data-node="D" style="left: calc(50% - var(--piece-size) / 2); top: calc(20% - var(--piece-size) / 2);">D</div> 
    <div class="node" id="E" data-node="E" style="left: calc(50% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">E</div> 
    <!-- F: Updated from 90% to 80% to align with inner circle intersection -->
    <div class="node" id="F" data-node="F" style="left: calc(50% - var(--piece-size) / 2); top: calc(80% - var(--piece-size) / 2);">F</div> 
    
    <!-- K Node (X=80%) -->
    <div class="node" id="K" data-node="K" style="left: calc(80% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">K</div>

    <!-- Right Line Nodes (X=100%) -->
    <div class="node" id="G" data-node="G" style="left: calc(100% - var(--piece-size) / 2); top: calc(10% - var(--piece-size) / 2);">G</div> 
    <div class="node" id="H" data-node="H" style="left: calc(100% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">H</div> 
    <div class="node" id="I" data-node="I" style="left: calc(100% - var(--piece-size) / 2); top: calc(90% - var(--piece-size) / 2);">I</div> 
    
  </div>

  <div class="controls-bottom">
    <button class="btn btn-green" id="btnNewGame">New Game</button>
    <button class="btn btn-gold" id="btnRules">Rules</button>
  </div>
</div>

<div id="modal">
  <div class="modal-box">
    <h2 id="modalTitle"></h2>
    <p id="modalMessage"></p>
    <button id="modalButton">Close</button>
  </div>
</div>

<script>
// --- Hobak Gonu Game Logic ---

// Nodes are labeled based on their position. J (20,50) and K (80,50) are the correct intersection points for the new circle radius.
const NODES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']; 

// Nodes where pieces cannot move back into once they are empty
const RESTRICTED_TARGET_NODES = ['A', 'C', 'G', 'I']; 

// EDGES: Connections for the 11-node board 
const EDGES = {
    // Left Line
    A: ['B'], 
    B: ['A', 'C', 'J'], // B connects to A, C, and J (entry point)
    C: ['B'], 
    
    // Center Axis / Circle Points (D, E, F, J, K form the interconnected center)
    D: ['E', 'J', 'K', 'F'], 
    E: ['D', 'F', 'J', 'K'], 
    F: ['E', 'J', 'K', 'D'], 
    
    // Right Line
    G: ['H'], 
    H: ['G', 'I', 'K'], // H connects to G, I, and K (entry point)
    I: ['H'],
    
    // New Entry Points (J & K are on the circle)
    J: ['B', 'E', 'D', 'F', 'K'], 
    K: ['H', 'E', 'D', 'F', 'J']  
};

// Initial state: P1 on A, B, C; P2 on G, H, I. J, K, D, E, F are empty.
const INITIAL_BOARD_STATE = {
    A: 'P1', B: 'P1', C: 'P1', 
    D: null, E: null, F: null, 
    G: 'P2', H: 'P2', I: 'P2',
    J: null, K: null 
};


// Global State
let board = {}; 
let currentPlayer = 'P1';
let phase = 'MOVEMENT'; 
let selectedPieceNode = null;
let moveCount = 0; 

// DOM Elements
const nodeEls = NODES.map(id => document.getElementById(id)).filter(el => el); 
// Removed gameLogEl reference

const p1Card = document.getElementById('player1Card');
const p2Card = document.getElementById('player2Card');
const modalEl = document.getElementById('modal');
const modalTitleEl = document.getElementById('modalTitle');
const modalMessageEl = document.getElementById('modalMessage');
const modalButtonEl = document.getElementById('modalButton');

// --- Core Logic ---

/**
 * Checks if a player has any legal moves remaining.
 * @param {string} player 'P1' or 'P2'
 * @returns {boolean} True if the player can move, false otherwise.
 */
function canMove(player) {
    for (const node of NODES) {
        if (board[node] === player) {
            const neighbors = EDGES[node] || [];
            if (neighbors.some(neighbor => {
                // If a neighbor is empty (null) and it's not a restricted target node, the piece can move.
                return board[neighbor] === null && !RESTRICTED_TARGET_NODES.includes(neighbor);
            })) {
                return true; 
            }
        }
    }
    return false;
}

/**
 * Resets the game state and UI to start a new game.
 */
function newGame() {
    // Reset state
    board = JSON.parse(JSON.stringify(INITIAL_BOARD_STATE)); // Deep copy initial state
    currentPlayer = 'P1';
    phase = 'MOVEMENT';
    selectedPieceNode = null;
    moveCount = 0; // Reset move counter
    
    // Update UI
    renderBoard();
    renderPlayerInfo();
    updateLog(`Game started. Player 1 (Yellow) must make the first move from B to J.`);
}

/**
 * Renders the state of the board pieces and highlights.
 */
function renderBoard() {
    // 1. Reset all nodes
    nodeEls.forEach(el => {
        el.className = 'node'; // Reset classes
        el.textContent = el.dataset.node; 
    });

    // 2. Render pieces
    for (const node of NODES) {
        const el = document.getElementById(node);
        if (!el) continue; 
        
        el.classList.remove('yellow', 'red');
        const player = board[node];
        
        if (player === 'P1') {
            el.classList.add('yellow', 'occupied');
        } else if (player === 'P2') {
            el.classList.add('red', 'occupied');
        } else {
            el.classList.remove('occupied');
        }
    }
    
    // 3. Render highlights (Movement Phase)
    if (phase === 'MOVEMENT') {
        const isP1FirstMove = moveCount === 0 && currentPlayer === 'P1';
        const isP2FirstMove = moveCount === 1 && currentPlayer === 'P2';

        if (selectedPieceNode) {
            // Highlight selected piece
            document.getElementById(selectedPieceNode).classList.add('current-piece');

            // Highlight legal target moves
            EDGES[selectedPieceNode].forEach(neighbor => {
                const isLegalTarget = board[neighbor] === null;
                const isRestrictedTarget = RESTRICTED_TARGET_NODES.includes(neighbor);
                
                if (isP1FirstMove) {
                    // Only J is the legal target for the first move (B->J)
                    if (selectedPieceNode === 'B' && neighbor === 'J') {
                        document.getElementById(neighbor).classList.add('target-move');
                    }
                } else if (isP2FirstMove) {
                    // Only K is the legal target for the second move (H->K)
                    if (selectedPieceNode === 'H' && neighbor === 'K') {
                        document.getElementById(neighbor).classList.add('target-move');
                    }
                } else if (isLegalTarget && !isRestrictedTarget) {
                    // Standard movement: must be empty AND not a restricted target node
                    document.getElementById(neighbor).classList.add('target-move');
                }
            });
        } else {
            // Highlight own pieces that can move (or just the mandated piece for the first two moves)
            nodeEls.forEach(el => {
                const node = el.dataset.node;
                
                if (board[node] === currentPlayer) {
                    if (isP1FirstMove) {
                        if (node === 'B') {
                            el.classList.add('selectable');
                        } else {
                            el.classList.add('disabled');
                        }
                    } else if (isP2FirstMove) {
                        if (node === 'H') {
                            el.classList.add('selectable');
                        } else {
                            el.classList.add('disabled');
                        }
                    } else if (canPieceMove(node)) {
                        // Standard movement: highlight all pieces that can move
                        el.classList.add('selectable');
                    }
                } else if (board[node] !== null && board[node] !== currentPlayer) {
                    // Disable opponent pieces
                    el.classList.add('disabled');
                }
            });
        }
    }
}

/**
 * Renders the current turn indicator.
 */
function renderPlayerInfo() {
    p1Card.classList.toggle('active', currentPlayer === 'P1');
    p2Card.classList.toggle('active', currentPlayer === 'P2');
}

/**
 * Handles a click event on a board node.
 * @param {string} node ID of the node clicked (A-I, J, K).
 */
function handleNodeClick(node) {
    if (phase !== 'MOVEMENT') return;
    
    const isPlayersPiece = board[node] === currentPlayer;
    const isTargetNode = selectedPieceNode && EDGES[selectedPieceNode].includes(node) && board[node] === null;
    
    const isP1FirstMove = moveCount === 0 && currentPlayer === 'P1';
    const isP2FirstMove = moveCount === 1 && currentPlayer === 'P2';

    if (!selectedPieceNode) {
        // 1. SELECT PIECE
        if (isPlayersPiece) {
            if (isP1FirstMove && node !== 'B') {
                updateLog('The very first move must start at B.');
            } else if (isP2FirstMove && node !== 'H') {
                updateLog('The second move must start at H.');
            } else if (!isP1FirstMove && !isP2FirstMove && !canPieceMove(node)) {
                 updateLog('That piece is blocked. Select one that can move.');
            } else {
                selectedPieceNode = node;
                updateLog(`Selected piece. Now choose an adjacent empty node.`);
                renderBoard();
            }
        } else {
            updateLog(`Select one of your ${getPlayerColor(currentPlayer)} pieces.`);
        }
    } else if (node === selectedPieceNode) {
        // 2. DESELECT PIECE
        selectedPieceNode = null;
        updateLog(`${getPlayerName(currentPlayer)}'s turn. Select a piece to move.`);
        renderBoard();

    } else if (isTargetNode) {
        // 3. MOVE PIECE
        
        // --- MOVEMENT RESTRICTIONS ---

        // A) ENFORCE FIRST TWO MOVES
        if (isP1FirstMove) {
            if (selectedPieceNode !== 'B' || node !== 'J') {
                updateLog('The very first move must be Player 1 moving from B to J.');
                selectedPieceNode = null; 
                renderBoard();
                return;
            }
        } else if (isP2FirstMove) {
            if (selectedPieceNode !== 'H' || node !== 'K') {
                updateLog('The second move must be Player 2 moving from H to K.');
                selectedPieceNode = null; 
                renderBoard();
                return;
            }
        }
        
        // B) RESTRICT MOVING BACK TO OUTER STARTING NODES (A, C, G, I)
        if (!isP1FirstMove && !isP2FirstMove && RESTRICTED_TARGET_NODES.includes(node)) {
             updateLog('Illegal move. You cannot move a piece back into the outer start/end positions (A, C, G, I).');
             selectedPieceNode = null;
             renderBoard();
             return;
        }

        // --- EXECUTE MOVE ---
        board[node] = currentPlayer;
        board[selectedPieceNode] = null;
        selectedPieceNode = null;
        moveCount++; // Increment move count
        
        // Render move immediately
        renderBoard();

        // Check for opponent win condition (opponent blocked)
        const opponent = currentPlayer === 'P1' ? 'P2' : 'P1';
        if (!canMove(opponent)) {
            endGame(currentPlayer);
        } else {
            switchPlayer();
            
            if (moveCount === 1) {
                updateLog(`Move 1 (B->J) complete. Player 2 (Red)'s turn. P2 must move from H to K.`);
            } else if (moveCount === 2) {
                updateLog(`Move 2 (H->K) complete. Player 1 (Yellow)'s turn. Standard movement begins.`);
            } else {
                updateLog(`${getPlayerName(currentPlayer)}'s turn. Select a piece to move.`);
            }
        }
    } else {
        // Invalid movement click or selecting a different piece
        if (isPlayersPiece && !isP1FirstMove && !isP2FirstMove) { 
            selectedPieceNode = node;
            updateLog(`Selected new piece. Choose an adjacent empty node.`);
            renderBoard();
        } else {
            updateLog('Invalid move. Select an adjacent empty spot.');
        }
    }
}

/**
 * Checks if a specific piece at a node can make a move.
 */
function canPieceMove(node) {
    if (board[node] !== currentPlayer) return false;
    // For standard movement, ensure at least one adjacent node is null AND not a restricted target
    return (EDGES[node] || []).some(neighbor => {
        const isLegalTarget = board[neighbor] === null;
        const isRestrictedTarget = RESTRICTED_TARGET_NODES.includes(neighbor);
        
        return isLegalTarget && !isRestrictedTarget;
    });
}

/**
 * Switches the current player.
 */
function switchPlayer() {
    currentPlayer = currentPlayer === 'P1' ? 'P2' : 'P1';
    renderPlayerInfo();
}

/**
 * Gets the display name for the current player.
 */
function getPlayerName(player) {
    return player === 'P1' ? 'Player 1 (Yellow)' : 'Player 2 (Red)';
}

/**
 * Gets the color name for the current player.
 */
function getPlayerColor(player) {
    return player === 'P1' ? 'Yellow' : 'Red';
}

/**
 * Ends the game and displays the winner modal.
 * @param {string} winner 'P1' or 'P2'
 */
function endGame(winner) {
    phase = 'GAME_OVER';
    updateLog(`Game Over! ${getPlayerName(winner)} wins!`);
    
    modalTitleEl.textContent = "🏆 Game Over!";
    modalMessageEl.innerHTML = `${getPlayerName(winner)} wins! The opponent could not make a legal move (all their pieces are blocked).`;
    modalButtonEl.textContent = "Start New Game";
    modalButtonEl.onclick = () => {
        modalEl.style.display = 'none';
        newGame();
    };
    modalEl.style.display = 'flex';
}

/**
 * Function to suppress game log updates, logging only to the console for debugging.
 * @param {string} message The message that would have been displayed.
 */
function updateLog(message) { 
    // Strips HTML tags and logs the status to the console.
    console.log("[Game Status]:", message.replace(/<[^>]*>?/gm, ''));
}


// --- UI / Event Setup ---

/**
 * Displays the rules of the game.
 */
function showRules() {
    modalTitleEl.textContent = "Hobak Gonu (Five Stone) Rules";
    modalMessageEl.innerHTML = `
      <div style="text-align: left; color: var(--light-gold); font-size: 0.95rem;">
        <p><strong>Goal:</strong> Block the opponent so they cannot make a legal move on their turn.</p>
        <p style="margin-top: 10px;"><strong>Board Setup:</strong></p>
        <ul style="list-style-type: disc; margin-left: 20px;">
          <li>The board has 11 nodes. **J** (at 20%) and **K** (at 80%) are the main entry points onto the smaller central circle.</li>
          <li>Player 1 (Yellow) starts with 3 pieces on the left line (A, B, C).</li>
          <li>Player 2 (Red) starts with 3 pieces on the right line (G, H, I).</li>
        </ul>
        <p style="margin-top: 10px;"><strong>The Opening Moves (Mandatory):</strong></p>
        <ul style="list-style-type: disc; margin-left: 20px;">
          <li>**Move 1 (P1):** Player 1 must move the piece from **B** to the entry point **J**.</li>
          <li>**Move 2 (P2):** Player 2 must move the piece from **H** to the entry point **K**.</li>
        </ul>
        <p style="margin-top: 10px;"><strong>Standard Movement:</strong></p>
        <ul style="list-style-type: disc; margin-left: 20px;">
          <li>A piece can only move to an **adjacent, empty node**.</li>
          <li>**Movement Restriction:** Pieces cannot move back into the starting corner nodes **A, C, G, or I**.</li>
        </ul>
        <p style="margin-top: 10px;"><strong>Winning:</strong></p>
        <p>A player loses if they cannot move on their turn (all of their pieces are blocked). The player who makes the last legal move wins.</p>
      </div>
    `;
    modalButtonEl.textContent = "Got It";
    modalButtonEl.onclick = () => { modalEl.style.display = 'none'; };
    modalEl.style.display = 'flex';
}

// Attach listeners to all nodes
nodeEls.forEach(el => {
    el.addEventListener('click', () => {
        if (phase === 'MOVEMENT') {
            handleNodeClick(el.dataset.node);
        }
    });
});

document.getElementById('btnNewGame').addEventListener('click', newGame);
document.getElementById('btnRules').addEventListener('click', showRules);

// Initialize the game when the script loads
newGame();
</script>
</body>
</html>

