<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Hobak Gonu</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
<style>
:root{
  --felt-green:#0a4821;
  --dark-wood:#2a1a1f;
  --gold:#ffd700;
  --gold-light:#ffd700;
  --light-gold:#fff8e1;
  --ivory:#faf8f0;
  --yellow-piece:#f9d924;
  --red-piece:#d13535;
  --piece-size: 30px;
}
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:'Roboto',sans-serif;
  background-color: var(--dark-wood);
  background-image: radial-gradient(circle, #4d322e 0%, var(--dark-wood) 70%);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 1rem;
  color: var(--light-gold);
}
.table {
  background: var(--felt-green);
  border: 10px solid #4a2c2a;
  box-shadow: 0 0 0 5px var(--gold), inset 0 0 25px rgba(0,0,0,0.5);
  border-radius: 15px;
  padding: 2rem;
  width: 100%;
  max-width: 800px;
  text-align: center;
  position: relative;
}
.header{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:12px;
  margin-bottom:12px;
}
.title{
  font-family:'Playfair Display', serif;
  color: var(--gold);
  font-size: 2.5rem;
  text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
  margin-bottom: 1.5rem;
  text-align: center;
}
/* Removed status-bar (game log) CSS */

.controls-bottom{
  display:flex;
  justify-content:center;
  gap:10px;
  margin-top:16px;
}
.btn{
  font-family:'Inter',sans-serif;
  font-weight:600;
  padding:10px 16px;
  border-radius:8px;
  border:2px solid #111;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:8px;
  box-shadow:0 6px 0 #111,0 8px 16px rgba(0,0,0,0.45);
  color:white;
  text-shadow:1px 1px 2px #000;
  transition:transform .1s, box-shadow .1s;
}
.btn:active{transform:translateY(3px);box-shadow:0 2px 0 #111;}
.btn-green{background:linear-gradient(145deg,#008c3a,#005a25)}
.btn-gold{background:linear-gradient(145deg,var(--gold-light),var(--gold)); color:var(--dark-wood); text-shadow:none;}

/* --- Board Styling --- */
.board-container{
  position:relative;
  width:100%;
  max-width:400px;
  aspect-ratio:1/1;
  margin:20px auto 0;
}
.board-svg{
  width:100%;
  height:100%;
  position:relative;
  z-index:1;
}
/* THINNER LINES */
.board-svg line, .board-svg circle{
  stroke:#fff;
  stroke-width:1.5; 
  stroke-linecap:round;
  filter:drop-shadow(1px 1px 2px rgba(0,0,0,0.8));
}
.board-svg circle{
    fill: none;
}
.node{
  position:absolute;
  width:var(--piece-size);height:var(--piece-size);
  border-radius:50%;
  background-color:transparent;
  border:2px solid transparent; 
  cursor:pointer;
  transition:transform .15s, box-shadow .15s, background-color .15s;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:0; 
  color:transparent;
  z-index:10;
}

/* 3. REMOVE ALL LETTER LABELS */
.node::after {
    content: none !important; 
}

/* Lighter border for occupied node (removed below, keeping this here for context) */
.node.occupied{cursor:pointer;border:none;}

/* HOVER STATE FOR EMPTY NODES - adds a slight visual cue */
.node:hover:not(.occupied):not(.disabled):not(.selectable){
  transform:scale(1.1);
  box-shadow:0 0 8px rgba(255,255,255,0.4);
  background-color: rgba(255, 255, 255, 0.1);
}

/* Casino-style 3D Token Styling */
.node.occupied {
    border: none !important;
    cursor: pointer;
    /* Casino-style 3D effect with deep shadows and highlights */
    box-shadow: 
        inset 8px 8px 16px rgba(0,0,0,0.35), /* deep inset shadow */
        inset -4px -4px 10px rgba(255,255,255,0.08), /* inner highlight */
        0 10px 20px rgba(0,0,0,0.6); /* strong bottom shadow */
}

/* --- CASINO-STYLE TOKENS --- */
.node.yellow{
  /* Casino-style gradient with rich colors */
  background: radial-gradient(120% 120% at 30% 20%, #f9d924, var(--yellow-piece) 40%, #c4a71c 100%);
  border: 2px solid #c4a71c;
  color: var(--dark-wood);
}
.node.red{
  /* Casino-style gradient with rich colors */
  background: radial-gradient(120% 120% at 30% 20%, #d13535, var(--red-piece) 40%, #a32727 100%);
  border: 2px solid #a32727;
  color: white;
}
/* ----------------------------------------------------------------- */


/* Selection States - Only glow around selected token */
.node.current-piece{
  transform: scale(1.1);
  /* Casino-style glow effect */
  box-shadow: 
    inset 8px 8px 16px rgba(0,0,0,0.35),
    inset -4px -4px 10px rgba(255,255,255,0.08),
    0 10px 20px rgba(0,0,0,0.6),
    0 0 25px var(--gold-light),
    0 0 40px rgba(255, 215, 0, 0.4);
}

/* Remove all target move highlighting - no special styling needed */

.node.disabled{cursor:default;}

/* Player Indicators */
.player-info {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 1.5rem 0;
    gap: 1rem;
}
.player-card {
    background: linear-gradient(145deg, #3e1e24, #2a1a1f);
    padding: 0.9rem;
    border-radius: 10px;
    width: 220px;
    border: 3px solid #1a1a1a;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5), 0 5px 15px rgba(0,0,0,0.4);
    color: var(--light-gold);
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.player-card.active {
    border-color: var(--gold);
    transform: scale(1.05);
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5), 0 5px 15px rgba(0,0,0,0.4), 0 0 20px var(--gold);
}
.piece-display {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    margin-bottom: 5px;
    /* Updated 3D styling to be consistent with main pieces */
    box-shadow: 
        inset 0 0 8px rgba(255, 255, 255, 0.6), /* inner highlight */
        0 3px 8px rgba(0, 0, 0, 0.6), /* bottom shadow */
        inset 0 0 10px rgba(255, 255, 255, 0.1); /* ambient shine */
}
/* --- CASINO-STYLE INDICATORS --- */
.piece-display.yellow { 
    background: radial-gradient(120% 120% at 30% 20%, #f9d924, var(--yellow-piece) 40%, #c4a71c 100%);
    border: 2px solid #c4a71c;
    box-shadow: 
        inset 6px 6px 12px rgba(0,0,0,0.3),
        inset -3px -3px 8px rgba(255,255,255,0.06),
        0 6px 12px rgba(0,0,0,0.4);
}
.piece-display.red { 
    background: radial-gradient(120% 120% at 30% 20%, #d13535, var(--red-piece) 40%, #a32727 100%);
    border: 2px solid #a32727;
    box-shadow: 
        inset 6px 6px 12px rgba(0,0,0,0.3),
        inset -3px -3px 8px rgba(255,255,255,0.06),
        0 6px 12px rgba(0,0,0,0.4);
}
/* ----------------------------------------------------------------------------- */
.player-header {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.4rem;
}
.player-header h2 {
    font-size: 1.1rem;
    color: var(--light-gold);
}
.edit-name-icon {
    cursor: pointer;
    font-size: 1.1rem;
    color: var(--gold);
    transition: transform 0.2s;
    border-radius: 4px;
}
.edit-name-icon:hover {
    transform: scale(1.2);
}
.player-name-input {
    background-color: var(--light-gold);
    border: 1px solid var(--gold);
    border-radius: 4px;
    padding: 4px;
    font-family: 'Roboto', sans-serif;
    text-align: center;
    width: 80%;
}
.player-name {
    color: var(--light-gold);
    font-weight: 700;
    font-size: 1.1rem;
}

/* Modal */
#modal{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.7);display:none;align-items:flex-start;justify-content:center;z-index:9999;
  padding-top: 2rem;
}
.modal-box{
  background:linear-gradient(145deg, #2a1a1f, var(--dark-wood));
  border:4px solid var(--gold);
  border-radius:14px;
  padding:30px;
  text-align:center;
  box-shadow:0 0 30px var(--gold-light);
  max-width:400px;
  margin-top: 1rem;
}
.modal-box h2{font-family:'Inter',sans-serif;font-size:1.8rem;color:var(--gold-light);margin-bottom:12px;text-shadow:0 0 10px black;}
.modal-box p{color:var(--light-gold);margin-bottom:20px;}
.modal-box button{background:linear-gradient(145deg,#008c3a,#005a25);color:white;border:none;padding:12px 20px;border-radius:8px;font-size:1rem;font-weight:700;cursor:pointer;}

</style>
</head>
<body>
<div class="table">
  <div class="header">
    <div class="title">Hobak Gonu</div>
    <!-- Removed status-bar/gameLog div -->
  </div>

  <!-- Player Info -->
  <div class="player-info">
    <div class="player-card" data-player="P1" id="player1Card">
        <div class="player-header">
            <h2 id="player1Name">Player 1</h2>
            <span class="edit-name-icon" id="editPlayer1" aria-label="Edit Player 1 Name">✏️</span>
        </div>
        <div class="piece-display yellow"></div>
        <div class="player-name">Yellow</div>
    </div>
    <div class="player-card" data-player="P2" id="player2Card">
        <div class="player-header">
            <h2 id="player2Name">Player 2</h2>
            <span class="edit-name-icon" id="editPlayer2" aria-label="Edit Player 2 Name">✏️</span>
        </div>
        <div class="piece-display red"></div>
        <div class="player-name">Red</div>
    </div>
  </div>

  <!-- Board -->
  <div class="board-container" id="boardContainer">
    <!-- SVG for Lines. Using (0,0) to (100,100) coordinate system. -->
    <svg class="board-svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
        <!-- Center Circle (Radius 30, centered at 50,50) -->
        <circle cx="50" cy="50" r="30" /> 

        <!-- Vertical Cross Line (D-E-F) -->
        <line x1="50" y1="20" x2="50" y2="80" /> 

        <!-- Left Vertical Line (A-B-C) - Positioned at X=0 -->
        <line x1="0" y1="20" x2="0" y2="80" />
        
        <!-- Right Vertical Line (G-H-I) - Positioned at X=100 -->
        <line x1="100" y1="20" x2="100" y2="80" />

        <!-- Horizontal Connecting Lines - Segmented for J (20,50) and K (80,50) -->
        
        <!-- B (0,50) to J (20,50) -->
        <line x1="0" y1="50" x2="20" y2="50" /> 
        <!-- J (20,50) to E (50,50) -->
        <line x1="20" y1="50" x2="50" y2="50" /> 
        
        <!-- H (100,50) to K (80,50) -->
        <line x1="100" y1="50" x2="80" y2="50" />
        <!-- K (80,50) to E (50,50) -->
        <line x1="80" y1="50" x2="50" y2="50" /> 
    </svg>
    
    <!-- Nodes (A-I, J, K) -->
    
    <!-- Left Line Nodes (X=0%) -->
    <div class="node" id="A" data-node="A" style="left: calc(0% - var(--piece-size) / 2); top: calc(20% - var(--piece-size) / 2);">A</div> 
    <div class="node" id="B" data-node="B" style="left: calc(0% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">B</div> 
    <div class="node" id="C" data-node="C" style="left: calc(0% - var(--piece-size) / 2); top: calc(80% - var(--piece-size) / 2);">C</div> 
    
    <!-- J Node (X=20%) -->
    <div class="node" id="J" data-node="J" style="left: calc(20% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">J</div>

    <!-- Center Cross Nodes (X=50%) -->
    <div class="node" id="D" data-node="D" style="left: calc(50% - var(--piece-size) / 2); top: calc(20% - var(--piece-size) / 2);">D</div> 
    <div class="node" id="E" data-node="E" style="left: calc(50% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">E</div> 
    <div class="node" id="F" data-node="F" style="left: calc(50% - var(--piece-size) / 2); top: calc(80% - var(--piece-size) / 2);">F</div> 
    
    <!-- K Node (X=80%) -->
    <div class="node" id="K" data-node="K" style="left: calc(80% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">K</div>

    <!-- Right Line Nodes (X=100%) -->
    <div class="node" id="G" data-node="G" style="left: calc(100% - var(--piece-size) / 2); top: calc(20% - var(--piece-size) / 2);">G</div> 
    <div class="node" id="H" data-node="H" style="left: calc(100% - var(--piece-size) / 2); top: calc(50% - var(--piece-size) / 2);">H</div> 
    <div class="node" id="I" data-node="I" style="left: calc(100% - var(--piece-size) / 2); top: calc(80% - var(--piece-size) / 2);">I</div> 
    
  </div>

  <div class="controls-bottom">
    <button class="btn btn-green" id="btnNewGame">New Game</button>
    <button class="btn btn-gold" id="btnRules">Rules</button>
  </div>
</div>

<div id="modal">
  <div class="modal-box">
    <h2 id="modalTitle"></h2>
    <p id="modalMessage"></p>
    <button id="modalButton">Close</button>
  </div>
</div>

<script>
// --- Hobak Gonu Game Logic ---

// Nodes are labeled based on their position. J (20,50) and K (80,50) are the correct intersection points for the new circle radius.
const NODES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']; 

// Nodes where pieces cannot move back into once they are empty
const RESTRICTED_TARGET_NODES = ['A', 'C', 'G', 'I']; 

// EDGES: Connections for the 11-node board (only along drawn lines, no skips/jumps)
const EDGES = {
    // Left vertical line
    A: ['B'],
    B: ['A', 'C', 'J'], // B connects to A, C, and J (entry point)
    C: ['B'],

    // Center cross and circle adjacent points
    // D connects to E (vertical) and to J and K via the circle (adjacent arcs only)
    D: ['E', 'J', 'K'],
    // E connects to D and F (vertical), and to J and K (horizontal)
    E: ['D', 'F', 'J', 'K'],
    // F connects to E (vertical) and to J and K via the circle (adjacent arcs only)
    F: ['E', 'J', 'K'],

    // Right vertical line
    G: ['H'],
    H: ['G', 'I', 'K'], // H connects to G, I, and K (entry point)
    I: ['H'],

    // Entry points on the circle (adjacent along circle only)
    // J connects to B (left), E (right), and adjacent circle points D and F
    J: ['B', 'E', 'D', 'F'],
    // K connects to H (right), E (left), and adjacent circle points D and F
    K: ['H', 'E', 'D', 'F']
};

// Initial state: P1 on A, B, C; P2 on G, H, I. J, K, D, E, F are empty.
const INITIAL_BOARD_STATE = {
    A: 'P1', B: 'P1', C: 'P1', 
    D: null, E: null, F: null, 
    G: 'P2', H: 'P2', I: 'P2',
    J: null, K: null 
};


// Global State
let board = {}; 
let currentPlayer = 'P1';
let phase = 'MOVEMENT'; 
let selectedPieceNode = null;
let moveCount = 0; 

// DOM Elements
const nodeEls = NODES.map(id => document.getElementById(id)).filter(el => el); 
// Removed gameLogEl reference

const p1Card = document.getElementById('player1Card');
const p2Card = document.getElementById('player2Card');
const modalEl = document.getElementById('modal');
const modalTitleEl = document.getElementById('modalTitle');
const modalMessageEl = document.getElementById('modalMessage');
const modalButtonEl = document.getElementById('modalButton');

// --- Core Logic ---

/**
 * Checks if a player has any legal moves remaining.
 * @param {string} player 'P1' or 'P2'
 * @returns {boolean} True if the player can move, false otherwise.
 */
function canMove(player) {
    for (const node of NODES) {
        if (board[node] === player) {
            const neighbors = EDGES[node] || [];
            if (neighbors.some(neighbor => {
                // If a neighbor is empty (null) and it's not a restricted target node, the piece can move.
                return board[neighbor] === null && !RESTRICTED_TARGET_NODES.includes(neighbor);
            })) {
                return true; 
            }
        }
    }
    return false;
}

/**
 * Resets the game state and UI to start a new game.
 */
function newGame() {
    // Reset state
    board = JSON.parse(JSON.stringify(INITIAL_BOARD_STATE)); // Deep copy initial state
    currentPlayer = 'P1';
    phase = 'MOVEMENT';
    selectedPieceNode = null;
    moveCount = 0; // Reset move counter
    
    // Update UI
    renderBoard();
    renderPlayerInfo();
    updateLog(`Game started. Player 1 (Yellow) must make the first move from B to J.`);
}

/**
 * Renders the state of the board pieces and highlights.
 */
function renderBoard() {
    // 1. Reset all nodes
    nodeEls.forEach(el => {
        el.className = 'node'; // Reset classes
        el.textContent = el.dataset.node; 
    });

    // 2. Render pieces
    for (const node of NODES) {
        const el = document.getElementById(node);
        if (!el) continue; 
        
        el.classList.remove('yellow', 'red');
        const player = board[node];
        
        if (player === 'P1') {
            el.classList.add('yellow', 'occupied');
        } else if (player === 'P2') {
            el.classList.add('red', 'occupied');
        } else {
            el.classList.remove('occupied');
        }
    }
    
    // 3. Render highlights (Movement Phase)
    if (phase === 'MOVEMENT') {
        const isP1FirstMove = moveCount === 0 && currentPlayer === 'P1';
        const isP2FirstMove = moveCount === 1 && currentPlayer === 'P2';

        if (selectedPieceNode) {
            // Highlight selected piece with casino-style glow
            document.getElementById(selectedPieceNode).classList.add('current-piece');

            // No target move highlighting - let players figure out valid moves
        } else {
            // Highlight own pieces that can move (or just the mandated piece for the first two moves)
            nodeEls.forEach(el => {
                const node = el.dataset.node;
                
                if (board[node] === currentPlayer) {
                    if (isP1FirstMove) {
                        if (node === 'B') {
                            el.classList.add('selectable');
                        } else {
                            el.classList.add('disabled');
                        }
                    } else if (isP2FirstMove) {
                        if (node === 'H') {
                            el.classList.add('selectable');
                        } else {
                            el.classList.add('disabled');
                        }
                    } else if (canPieceMove(node)) {
                        // Standard movement: highlight all pieces that can move
                        el.classList.add('selectable');
                    }
                } else if (board[node] !== null && board[node] !== currentPlayer) {
                    // Disable opponent pieces
                    el.classList.add('disabled');
                }
            });
        }
    }
}

/**
 * Renders the current turn indicator.
 */
function renderPlayerInfo() {
    p1Card.classList.toggle('active', currentPlayer === 'P1');
    p2Card.classList.toggle('active', currentPlayer === 'P2');
}

/**
 * Handles a click event on a board node.
 * @param {string} node ID of the node clicked (A-I, J, K).
 */
function handleNodeClick(node) {
    if (phase !== 'MOVEMENT') return;
    
    const isPlayersPiece = board[node] === currentPlayer;
    const isTargetNode = selectedPieceNode && EDGES[selectedPieceNode].includes(node) && board[node] === null;
    
    const isP1FirstMove = moveCount === 0 && currentPlayer === 'P1';
    const isP2FirstMove = moveCount === 1 && currentPlayer === 'P2';

    if (!selectedPieceNode) {
        // 1. SELECT PIECE
        if (isPlayersPiece) {
            if (isP1FirstMove && node !== 'B') {
                updateLog('The very first move must start at B.');
            } else if (isP2FirstMove && node !== 'H') {
                updateLog('The second move must start at H.');
            } else if (!isP1FirstMove && !isP2FirstMove && !canPieceMove(node)) {
                 updateLog('That piece is blocked. Select one that can move.');
            } else {
                selectedPieceNode = node;
                updateLog(`Selected piece. Now choose an adjacent empty node.`);
                renderBoard();
            }
        } else {
            updateLog(`Select one of your ${getPlayerColor(currentPlayer)} pieces.`);
        }
    } else if (node === selectedPieceNode) {
        // 2. DESELECT PIECE
        selectedPieceNode = null;
        updateLog(`${getPlayerName(currentPlayer)}'s turn. Select a piece to move.`);
        renderBoard();

    } else if (isTargetNode) {
        // 3. MOVE PIECE
        
        // --- MOVEMENT RESTRICTIONS ---

        // A) ENFORCE FIRST TWO MOVES
        if (isP1FirstMove) {
            if (selectedPieceNode !== 'B' || node !== 'J') {
                updateLog('The very first move must be Player 1 moving from B to J.');
                selectedPieceNode = null; 
                renderBoard();
                return;
            }
        } else if (isP2FirstMove) {
            if (selectedPieceNode !== 'H' || node !== 'K') {
                updateLog('The second move must be Player 2 moving from H to K.');
                selectedPieceNode = null; 
                renderBoard();
                return;
            }
        }
        
        // B) RESTRICT MOVING BACK TO OUTER STARTING NODES (A, C, G, I)
        if (!isP1FirstMove && !isP2FirstMove && RESTRICTED_TARGET_NODES.includes(node)) {
             updateLog('Illegal move. You cannot move a piece back into the outer start/end positions (A, C, G, I).');
             selectedPieceNode = null;
             renderBoard();
             return;
        }
        
        // C) CHECK IF MOVE IS VALID (adjacent and empty)
        if (!EDGES[selectedPieceNode].includes(node)) {
            updateLog('Invalid move. You can only move to adjacent nodes along drawn lines.');
            selectedPieceNode = null;
            renderBoard();
            return;
        }

        // --- EXECUTE MOVE ---
        board[node] = currentPlayer;
        board[selectedPieceNode] = null;
        selectedPieceNode = null;
        moveCount++; // Increment move count
        
        // Render move immediately
        renderBoard();

        // Check for opponent win condition (opponent blocked)
        const opponent = currentPlayer === 'P1' ? 'P2' : 'P1';
        if (!canMove(opponent)) {
            endGame(currentPlayer);
        } else {
            switchPlayer();
            
            if (moveCount === 1) {
                updateLog(`Move 1 (B->J) complete. Player 2 (Red)'s turn. P2 must move from H to K.`);
            } else if (moveCount === 2) {
                updateLog(`Move 2 (H->K) complete. Player 1 (Yellow)'s turn. Standard movement begins.`);
            } else {
                updateLog(`${getPlayerName(currentPlayer)}'s turn. Select a piece to move.`);
            }
        }
    } else {
        // Invalid movement click or selecting a different piece
        if (isPlayersPiece && !isP1FirstMove && !isP2FirstMove) { 
            selectedPieceNode = node;
            updateLog(`Selected new piece. Choose an adjacent empty node.`);
            renderBoard();
        } else {
            updateLog('Invalid move. Select an adjacent empty spot.');
        }
    }
}

/**
 * Checks if a specific piece at a node can make a move.
 */
function canPieceMove(node) {
    if (board[node] !== currentPlayer) return false;
    // For standard movement, ensure at least one adjacent node is null AND not a restricted target
    return (EDGES[node] || []).some(neighbor => {
        const isLegalTarget = board[neighbor] === null;
        const isRestrictedTarget = RESTRICTED_TARGET_NODES.includes(neighbor);
        
        return isLegalTarget && !isRestrictedTarget;
    });
}

/**
 * Switches the current player.
 */
function switchPlayer() {
    currentPlayer = currentPlayer === 'P1' ? 'P2' : 'P1';
    renderPlayerInfo();
}

/**
 * Gets the display name for the current player.
 */
function getPlayerName(player) {
    const playerName = player === 'P1' ? 
        document.getElementById('player1Name').textContent : 
        document.getElementById('player2Name').textContent;
    const color = player === 'P1' ? 'Yellow' : 'Red';
    return `${playerName} (${color})`;
}

/**
 * Gets the color name for the current player.
 */
function getPlayerColor(player) {
    return player === 'P1' ? 'Yellow' : 'Red';
}

/**
 * Ends the game and displays the winner modal.
 * @param {string} winner 'P1' or 'P2'
 */
function endGame(winner) {
    phase = 'GAME_OVER';
    updateLog(`${getPlayerName(winner)} wins!`);
    
    modalTitleEl.textContent = `🏆 ${getPlayerName(winner)} wins!`;
    modalMessageEl.innerHTML = `Congratulations!`;
    modalButtonEl.textContent = "Start New Game";
    modalButtonEl.onclick = () => {
        modalEl.style.display = 'none';
        newGame();
    };
    modalEl.style.display = 'flex';
}

/**
 * Function to suppress game log updates, logging only to the console for debugging.
 * @param {string} message The message that would have been displayed.
 */
function updateLog(message) { 
    // Strips HTML tags and logs the status to the console.
    console.log("[Game Status]:", message.replace(/<[^>]*>?/gm, ''));
}


// --- UI / Event Setup ---

/**
 * Displays the rules of the game.
 */
function showRules() {
    modalTitleEl.textContent = "Hobak Gonu";
    modalMessageEl.innerHTML = `
      <div style="text-align: left; color: var(--light-gold); font-size: 0.95rem;">
        <p><strong>Goal:</strong> Block the opponent so they cannot make a legal move on their turn.</p>
        <p style="margin-top: 10px;"><strong>Board Setup:</strong></p>
        <ul style="list-style-type: disc; margin-left: 20px;">
          <li>The board has 11 nodes. **J** (at 20%) and **K** (at 80%) are the main entry points onto the smaller central circle.</li>
          <li>Player 1 (Yellow) starts with 3 pieces on the left line (A, B, C).</li>
          <li>Player 2 (Red) starts with 3 pieces on the right line (G, H, I).</li>
        </ul>
        <p style="margin-top: 10px;"><strong>The Opening Moves (Mandatory):</strong></p>
        <ul style="list-style-type: disc; margin-left: 20px;">
          <li>**Move 1 (P1):** Player 1 must move the piece from **B** to the entry point **J**.</li>
          <li>**Move 2 (P2):** Player 2 must move the piece from **H** to the entry point **K**.</li>
        </ul>
        <p style="margin-top: 10px;"><strong>Standard Movement:</strong></p>
        <ul style="list-style-type: disc; margin-left: 20px;">
          <li>A piece can only move to an **adjacent, empty node** along a **drawn line**.</li>
          <li><strong>No skipping intersections:</strong> Moves are one edge at a time.</li>
          <li><strong>No jumping:</strong> You cannot jump over or pass through another piece.</li>
          <li><strong>Restriction:</strong> Pieces cannot move back into the starting corner nodes **A, C, G, or I**.</li>
        </ul>
        <p style="margin-top: 10px;"><strong>Winning:</strong></p>
        <p>A player loses if they cannot move on their turn (all of their pieces are blocked). The player who makes the last legal move wins.</p>
      </div>
    `;
    modalButtonEl.textContent = "Got It";
    modalButtonEl.onclick = () => { modalEl.style.display = 'none'; };
    modalEl.style.display = 'flex';
}

// Attach listeners to all nodes
nodeEls.forEach(el => {
    el.addEventListener('click', () => {
        if (phase === 'MOVEMENT') {
            handleNodeClick(el.dataset.node);
        }
    });
});

document.getElementById('btnNewGame').addEventListener('click', newGame);
document.getElementById('btnRules').addEventListener('click', showRules);

// Player name editing functionality
function setupPlayerNameEditing() {
    const editPlayer1 = document.getElementById('editPlayer1');
    const editPlayer2 = document.getElementById('editPlayer2');
    const player1Name = document.getElementById('player1Name');
    const player2Name = document.getElementById('player2Name');

    function setupEditFunctionality(editIcon, nameElement, defaultName) {
        editIcon.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = nameElement.textContent;
            input.placeholder = 'Enter name';
            input.className = 'player-name-input';
            input.style.width = '100%';
            input.style.marginTop = '0.2rem';
            
            nameElement.parentNode.replaceChild(input, nameElement);
            input.focus();
            input.select();
            
            const save = () => {
                const val = (input.value || '').trim();
                const newName = val.length ? val : defaultName;
                nameElement.textContent = newName;
                input.parentNode.replaceChild(nameElement, input);
            };
            
            input.addEventListener('blur', save);
            input.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                }
            });
        });
    }

    setupEditFunctionality(editPlayer1, player1Name, 'Player 1');
    setupEditFunctionality(editPlayer2, player2Name, 'Player 2');
}

// Initialize player name editing
setupPlayerNameEditing();

// Initialize the game when the script loads
newGame();
</script>
</body>
</html>

