<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node Graph Recreation</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Set body font to Inter and provide a dark canvas background */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }

        /* Canvas styling to match the inner light gray area of the original image */
        #graphCanvas {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            background-color: #f0f0f0; /* Light gray background for the graph area */
            border: 8px solid #333; /* Dark border to frame the canvas */
            border-radius: 1.5rem; /* Rounded corners for the container */
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
            display: block;
        }
    </style>
</head>
<body class="selection:bg-red-400 selection:text-white">

<div class="w-full max-w-lg mx-auto">
    <!-- Canvas element where the graph will be drawn -->
    <canvas id="graphCanvas" width="600" height="600"></canvas>
</div>

<script>
    // Constants for drawing
    const CANVAS_WIDTH = 600;
    const CANVAS_HEIGHT = 600;
    const NODE_RADIUS = 28;
    const LINE_COLOR = '#333333';
    const LINE_WIDTH = 4;
    const FONT_STYLE = `${NODE_RADIUS * 0.5}px Inter`;
    const TEXT_COLOR = '#333333';

    /* * Node coordinates have been adjusted to create maximum space in the middle.
     * The gap between the two closest inner columns (C and K) is now 250 units.
     */
    const nodes = {
        // Left Cluster (Brown/Gray)
        A: { x: 75, y: 150, label: 'A', color: '#B5A599' }, // 100 -> 75
        C: { x: 175, y: 150, label: 'C', color: '#B5A599' }, // 200 -> 175
        D: { x: 75, y: 300, label: 'D', color: '#B5A599' },
        F: { x: 175, y: 300, label: 'F', color: '#B5A599' },
        G: { x: 75, y: 450, label: 'G', color: '#B5A599' },
        H: { x: 175, y: 450, label: 'H', color: '#B5A599' },

        // Central Node (New)
        M: { x: 300, y: 300, label: 'M', color: '#FFD700' }, // Gold color for central connector

        // Right Cluster (Red)
        K: { x: 425, y: 150, label: 'K', color: '#E57373' }, // 400 -> 425
        L: { x: 525, y: 150, label: 'L', color: '#E57373' }, // 500 -> 525
        N: { x: 425, y: 300, label: 'N', color: '#E57373' },
        O: { x: 525, y: 300, label: 'O', color: '#E57373' },
        P: { x: 425, y: 450, label: 'P', color: '#E57373' },
        R: { x: 525, y: 450, label: 'R', color: '#E57373' },
    };

    // Edge data: connections adjusted to flow through the central 'M' node
    const edges = [
        // Left Internal (Horizontal)
        ['A', 'C'], ['D', 'F'], ['G', 'H'],
        // Left Internal (Vertical)
        ['A', 'D'], ['D', 'G'], ['C', 'F'], ['F', 'H'],

        // Right Internal (Horizontal)
        ['K', 'L'], ['N', 'O'], ['P', 'R'],
        // Right Internal (Vertical)
        ['K', 'N'], ['N', 'P'], ['L', 'O'], ['O', 'R'],

        // Connecting (Crossover) - All connections now pass through 'M'
        ['C', 'M'], ['M', 'P'], // C to P via M
        ['H', 'M'], ['M', 'K'], // H to K via M
        ['F', 'M'], ['M', 'N'], // F to N via M
    ];

    // External Labels removed as requested
    const externalLabels = [];


    function drawGraph() {
        const canvas = document.getElementById('graphCanvas');
        if (!canvas) return;

        // Reset canvas size to handle potential responsiveness issues on redraw
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const ctx = canvas.getContext('2d');
        // Clear the canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // --- 1. Draw Edges (Lines) ---
        ctx.strokeStyle = LINE_COLOR;
        ctx.lineWidth = LINE_WIDTH;
        ctx.lineCap = 'round';

        ctx.beginPath();
        edges.forEach(([node1Key, node2Key]) => {
            const n1 = nodes[node1Key];
            const n2 = nodes[node2Key];
            if (n1 && n2) {
                ctx.moveTo(n1.x, n1.y);
                ctx.lineTo(n2.x, n2.y);
            }
        });
        ctx.stroke();

        // --- 2. Draw Nodes (Circles) and Labels ---
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = FONT_STYLE;
        ctx.fillStyle = TEXT_COLOR;

        // Draw nodes in an order that ensures 'M' is drawn last to overlap lines, if necessary
        const allNodes = Object.values(nodes);
        
        // Draw all nodes except M first
        allNodes.filter(node => node.label !== 'M').forEach(node => {
            drawNode(ctx, node);
        });

        // Draw node M last to ensure it sits on top of all connecting lines
        const nodeM = nodes.M;
        if (nodeM) {
            drawNode(ctx, nodeM);
        }
    }

    // Helper function to draw a single node (circle and label)
    function drawNode(ctx, node) {
        // Draw Node Circle
        ctx.beginPath();
        ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);

        // Apply fill color
        ctx.fillStyle = node.color;
        
        // Add a subtle shadow to mimic the original image's depth
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.fill();

        // Reset shadow for text drawing (important for clear text)
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // Draw Node Label
        ctx.fillStyle = TEXT_COLOR;
        ctx.fillText(node.label, node.x, node.y);
    }

    // Run the drawing function when the window loads
    window.onload = drawGraph;

    // Optional: Redraw on window resize (for responsiveness, though dimensions are fixed)
    window.addEventListener('resize', drawGraph);
</script>
</body>
</html>

