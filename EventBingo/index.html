<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EventBingo</title>
  <style>
    :root {
      --primary: #4a90e2;
      --secondary: #7b68ee;
      --accent: #ff6b6b;
      --success: #51cf66;
      --text-dark: #2c3e50;
      --text-light: #ffffff;
      --bg-light: rgba(255, 255, 255, 0.95);
      --bg-dark: rgba(44, 62, 80, 0.9);
      --instagram-pink: #E4405F;
      --instagram-purple: #833AB4;
      --instagram-orange: #F77737;
      --instagram-yellow: #FCAF45;
      --story-gradient: linear-gradient(45deg, var(--instagram-pink), var(--instagram-purple), var(--instagram-orange), var(--instagram-yellow));
    }

    html, body {
      font-family: 'Segoe UI', sans-serif;
      background: #fafafa;
      color: var(--text-dark);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow-x: hidden;
      height: 100%;
    }

    /* Reset any potential conflicts */
    * {
      box-sizing: border-box;
    }

    /* Instagram-style Top Bar */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--bg-light);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .player-scroll {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      padding: 5px 0;
      width: 100%;
      flex: 1;
    }

    .player-scroll::-webkit-scrollbar {
      display: none;
    }

    .player-circle {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: white;
      border: 3px solid transparent;
      background-image: linear-gradient(white, white), var(--story-gradient);
      background-origin: border-box;
      background-clip: content-box, border-box;
      color: #333;
      font-weight: bold;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
      flex-shrink: 0;
      position: relative;
    }

    .player-circle:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .player-circle.active {
      border: 4px solid #ff0000;
      background-image: linear-gradient(#fff3f3, #fff3f3), linear-gradient(45deg, #ff0000, #ff4444);
      box-shadow: 0 0 0 2px rgba(255, 0, 0, 0.3), 0 0 12px rgba(255, 0, 0, 0.5);
    }

    .player-circle::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 50%;
      background: var(--story-gradient);
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .player-circle:hover::before {
      opacity: 1;
    }

    .player-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      cursor: pointer;
    }

    .top-bar .player-name {
      font-size: 0.8rem !important;
      color: var(--text-dark);
      font-weight: 400;
      text-align: center;
      max-width: none; /* allow full name */
      overflow: visible; /* do not truncate */
      text-overflow: clip;
      white-space: normal; /* allow wrapping */
      line-height: 1.2;
    }

    body.dark-mode .top-bar .player-name {
      color: #e0e0e0;
    }

    /* Dark mode player circles */
    body.dark-mode .player-circle {
      background-image: linear-gradient(#2d2d2d, #2d2d2d), var(--story-gradient);
      color: #ffffff;
    }

    body.dark-mode .player-avatar {
      background-image: linear-gradient(#2d2d2d, #2d2d2d), var(--story-gradient);
      color: #ffffff;
    }

    /* Ensure light-mode player names are visible in the top bar */
    .top-bar .player-name { color: #1f2937; }

    .share-icon {
      font-size: 1.5rem;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background-color 0.2s ease;
    }

    .share-icon:hover {
      background-color: rgba(0,0,0,0.1);
    }

    /* Main Content Area */
    .main-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 10px;
      padding-bottom: 100px; /* Extra space for bottom nav */
      min-height: calc(100vh - 200px);
    }

    h1 {
      text-align: center;
      color: var(--text-light);
      font-size: 2.2rem;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      font-weight: bold;
    }

    .controls {
      text-align: center;
      margin-bottom: 20px;
      background: var(--bg-light);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
    }

    select, input[type="text"], button {
      padding: 12px 16px;
      font-size: 1rem;
      margin: 8px;
      border-radius: 10px;
      border: 2px solid var(--primary);
      background: var(--bg-light);
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }

    select:focus, input[type="text"]:focus {
      outline: none;
      border-color: var(--secondary);
      box-shadow: 0 0 0 3px rgba(123, 104, 238, 0.2);
      transform: translateY(-1px);
    }

    /* Smooth transitions for input styling changes */
    input[type="text"] {
      transition: all 0.3s ease;
    }

    button {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--text-light);
      cursor: pointer;
      border: none;
      font-weight: 600;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
    }

    .leaderboard {
      text-align: center;
      margin-top: 10px;
      font-size: 1rem;
      color: var(--accent);
    }

    .loading-spinner {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.3);
      z-index: 9999;
      justify-content: center;
      align-items: center;
    }

    .loading-spinner .spinner-container {
      background: var(--bg-light);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid rgba(74, 144, 226, 0.3);
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: inline-block;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Modal Loading Spinner */
    .modal-loading {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 200px;
      flex-direction: column;
      gap: 15px;
    }

    .modal-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #ffffff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Inline Loading Spinner */
    .inline-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 20px;
      color: var(--primary);
      font-style: italic;
    }

    .inline-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(74, 144, 226, 0.3);
      border-top: 2px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Button Loading State */
    .button-loading {
      position: relative;
      pointer-events: none;
      opacity: 0.7;
    }

    .button-loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid #ffffff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .button-loading .add-text,
    .button-loading .add-icon {
      opacity: 0;
    }

    /* Page Loading Overlay */
    .page-loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(250, 250, 250, 0.95);
      z-index: 10000;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 20px;
    }

    .page-loading.hidden {
      display: none;
    }

    .page-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(74, 144, 226, 0.3);
      border-top: 5px solid var(--primary);
      border-radius: 50%;
      animation: spin 1.2s linear infinite;
    }

    .page-loading-text {
      font-size: 1.1rem;
      color: var(--primary);
      font-weight: 600;
    }

    /* Dark mode loading styles */
    body.dark-mode .page-loading {
      background: rgba(26, 26, 26, 0.95);
    }

    body.dark-mode .page-loading-text {
      color: #ffffff;
    }

    body.dark-mode .inline-loading {
      color: #ffffff;
    }

    .progress-table {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--bg-light);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      z-index: 1000;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      backdrop-filter: blur(10px);
    }

    .main-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    @media (min-width: 769px) {
      .main-container {
        display: grid;
        grid-template-columns: 1fr 300px;
        grid-template-rows: auto auto;
        gap: 20px;
      }
      
      .progress-table {
        grid-column: 2;
        grid-row: 1 / -1;
        position: sticky;
        top: 20px;
        height: fit-content;
      }
      
      .controls {
        grid-column: 1;
        grid-row: 1;
      }
      
      .grid {
        grid-column: 1;
        grid-row: 2;
      }
    }

    @media (max-width: 768px) {
      .progress-table {
        position: relative;
        top: auto;
        right: auto;
        margin: 0 auto 20px auto;
        max-width: 100%;
      }
    }

    .progress-table h3 {
      margin: 0 0 10px 0;
      color: var(--primary);
      font-size: 1rem;
    }

    .progress-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
      border-bottom: 1px solid var(--gray);
    }

    .progress-row:last-child {
      border-bottom: none;
    }

    .progress-name {
      font-weight: bold;
      color: var(--text-dark);
    }

    .progress-count {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--text-light);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: bold;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 10px;
      margin-top: 15px;
      align-items: start;
    }

    @media (max-width: 768px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }
    }

    .card {
      background: white;
      border-radius: 12px;
      margin-bottom: 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      overflow: hidden;
      position: relative;
      padding: 15px;
      border: 1px solid rgba(0,0,0,0.05);
    }

    .card:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    }

    .card::after {
      content: "üì∏";
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 1.2rem;
      opacity: 0.7;
      z-index: 10;
    }

    .card.completed::after {
      content: "‚úÖ";
      opacity: 1;
    }

    .card-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-bottom: 10px;
    }

    .card-photo {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .card p {
      margin: 0 0 10px 0;
      font-size: 1rem;
      line-height: 1.5;
      color: var(--text-dark);
      font-weight: 500;
    }

    input[type="file"] {
      margin-top: 5px;
      font-size: 0.9rem;
    }

    img {
      width: 100%;
      max-width: 100%;
      height: auto;
      margin-top: 10px;
      border-radius: 12px;
      border: 3px solid var(--primary);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      display: block;
    }

    img:hover {
      transform: scale(1.02);
      box-shadow: 0 6px 20px rgba(0,0,0,0.2);
    }

    /* Clickable photo styling */
    img[onclick] {
      cursor: pointer;
      transition: all 0.3s ease;
    }

    img[onclick]:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(74, 144, 226, 0.3);
    }

    img[onclick]:active {
      transform: scale(0.98);
    }

    /* Photo loading states */
    .photo-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100px;
      background: rgba(74, 144, 226, 0.1);
      border-radius: 12px;
      border: 2px dashed var(--primary);
      color: var(--primary);
      font-style: italic;
    }

    .photo-error {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100px;
      background: rgba(255, 107, 107, 0.1);
      border-radius: 12px;
      border: 2px dashed var(--accent);
      color: var(--accent);
      font-style: italic;
    }

    /* Ensure photos maintain aspect ratio */
    .card-photo img {
      max-height: 400px;
      object-fit: contain;
      background: rgba(255, 255, 255, 0.5);
    }

    /* Add a subtle overlay to indicate clickability */
    .card-photo img[onclick]::after {
      content: "üîç Click to view full size";
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .card-photo:hover img[onclick]::after {
      opacity: 1;
    }

    /* Photo link styling */
    .card-photo a {
      display: block;
      margin-bottom: 8px;
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.9rem;
      text-align: center;
      padding: 8px 12px;
      background: rgba(74, 144, 226, 0.1);
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .card-photo a:hover {
      background: rgba(74, 144, 226, 0.2);
      transform: translateY(-1px);
    }

    /* Upload section styling */
    .upload-section {
      margin-top: 10px;
      text-align: center;
    }

    .add-photo-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--text-light);
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(74, 144, 226, 0.3);
    }

    .add-photo-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(74, 144, 226, 0.4);
    }

    .add-photo-btn:active {
      transform: translateY(0);
    }

    .add-icon {
      font-size: 1.2rem;
      font-weight: bold;
      line-height: 1;
    }

    .add-text {
      font-size: 0.95rem;
    }

    /* Hide upload section when photo is loaded */
    .upload-section.hidden {
      display: none;
    }

    /* Event Banner */
    .event-banner {
      background: var(--story-gradient);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      position: sticky;
      top: 60px;
      z-index: 999;
      color: white;
    }

    .event-banner-info {
      flex: 1;
      min-width: 0;
    }

    .event-banner-title {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .event-banner-code {
      font-size: 0.75rem;
      opacity: 0.9;
    }

    .event-banner-link {
      color: white;
      text-decoration: none;
      padding: 6px 12px;
      background: rgba(255,255,255,0.2);
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      white-space: nowrap;
      transition: background 0.2s;
      margin-left: 12px;
    }

    .event-banner-link:hover {
      background: rgba(255,255,255,0.3);
    }

    /* Bottom Navigation Bar */
    .bottom-nav {
      position: fixed !important;
      bottom: 0 !important;
      left: 0 !important;
      right: 0 !important;
      width: 100vw !important;
      background: var(--bg-light);
      display: flex;
      justify-content: space-around;
      padding: 16px 0;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      z-index: 9999 !important;
      margin: 0 !important;
      border-top: 1px solid rgba(0,0,0,0.1);
      transform: translateZ(0);
    }

    /* Force bottom navigation to stay at bottom */
    .bottom-nav {
      position: fixed !important;
      bottom: 0 !important;
      top: auto !important;
      left: 0 !important;
      right: 0 !important;
      transform: none !important;
    }

    .nav-icon {
      font-size: 1.8rem;
      cursor: pointer;
      padding: 10px 14px;
      border-radius: 12px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 48px;
      min-height: 48px;
    }

    .nav-icon:hover {
      background-color: rgba(0,0,0,0.1);
      transform: translateY(-2px);
    }

    .nav-icon.active {
      background: var(--story-gradient);
      color: white;
      box-shadow: 0 4px 12px rgba(228, 64, 95, 0.3);
    }

    /* Add Player button styling in event banner */
    #addPlayerTopBtn {
      transition: all 0.2s ease;
    }
    
    #addPlayerTopBtn:hover {
      background: rgba(255,255,255,0.2) !important;
      transform: translateY(-1px);
    }

    /* Carousel Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .modal.show {
      display: flex;
    }

    .carousel-content {
      max-width: 90%;
      max-height: 90%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .carousel-image {
      max-width: 100%;
      max-height: 70vh;
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .carousel-close {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 2rem;
      color: white;
      cursor: pointer;
    }

    .carousel-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      pointer-events: none;
    }

    .carousel-prev,
    .carousel-next {
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      font-size: 2rem;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      pointer-events: all;
      transition: background-color 0.2s ease;
    }

    .carousel-prev:hover,
    .carousel-next:hover {
      background: rgba(0,0,0,0.7);
    }

    .carousel-counter {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
    }

    /* Leaderboard Modal - Dark Celebration Theme */
    .leaderboard-content {
      max-width: 90%;
      max-height: 90%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      border-radius: 20px;
      padding: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      border: 2px solid #ffd700;
    }

    .leaderboard-close {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 2rem;
      color: #ffd700;
      cursor: pointer;
      z-index: 10;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .leaderboard-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .leaderboard-header h2 {
      font-size: 2rem;
      color: #ffd700;
      margin: 0 0 10px 0;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      font-family: 'Segoe UI', sans-serif;
    }

    .leaderboard-header p {
      color: #e0e0e0;
      margin: 0;
      font-size: 1.1rem;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .leaderboard-list {
      width: 100%;
      max-width: 500px;
      margin-bottom: 30px;
    }

    .leaderboard-entry {
      display: flex;
      align-items: center;
      padding: 20px;
      margin-bottom: 15px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      border: 2px solid transparent;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
      color: #ffffff;
    }

    .leaderboard-entry::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }

    .leaderboard-entry:hover::before {
      left: 100%;
    }

    .leaderboard-entry:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .leaderboard-entry.first {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      color: #000000;
      border-color: #ffd700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    }

    .leaderboard-entry.first .player-name,
    .leaderboard-entry.first .player-title {
      color: #000000;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }

    .leaderboard-entry.second {
      background: linear-gradient(135deg, #c0c0c0, #e8e8e8);
      color: #000000;
      border-color: #c0c0c0;
      box-shadow: 0 0 25px rgba(192, 192, 192, 0.4);
    }

    .leaderboard-entry.second .player-name,
    .leaderboard-entry.second .player-title {
      color: #000000;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }

    .leaderboard-entry.third {
      background: linear-gradient(135deg, #cd7f32, #daa520);
      color: #000000;
      border-color: #cd7f32;
      box-shadow: 0 0 20px rgba(205, 127, 50, 0.4);
    }

    .leaderboard-entry.third .player-name,
    .leaderboard-entry.third .player-title {
      color: #000000;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }

    .rank {
      font-size: 2rem;
      font-weight: bold;
      margin-right: 20px;
      min-width: 50px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3));
    }

    .player-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .player-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: white;
      border: 3px solid transparent;
      background-image: linear-gradient(white, white), var(--story-gradient);
      background-origin: border-box;
      background-clip: content-box, border-box;
      color: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.4rem;
      box-shadow: 0 0 15px rgba(0,0,0,0.3);
    }

    .player-details {
      flex: 1;
    }

    .leaderboard-entry .player-name {
      font-weight: bold;
      font-size: 1.3rem;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      color: #ffffff;
    }

    .player-title {
      font-size: 1rem;
      opacity: 0.9;
      font-style: italic;
      color: #e0e0e0;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
    }

    .leaderboard-stats {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .stat-item {
      text-align: center;
      padding: 15px 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      border: 1px solid rgba(255, 215, 0, 0.3);
      backdrop-filter: blur(10px);
    }

    .stat-number {
      display: block;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffd700;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .stat-label {
      font-size: 0.9rem;
      color: #e0e0e0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .celebrate-button {
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 25px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .celebrate-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.5);
    }

    .celebrate-button:active {
      transform: translateY(-1px);
    }

    /* Fireworks animation */
    .fireworks {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .firework {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      animation: firework-explode 2s ease-out infinite;
    }

    @keyframes firework-explode {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      50% {
        transform: scale(1);
        opacity: 0.8;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    /* Filter Bar */
    .filter-bar {
      background: white;
      padding: 12px 15px;
      margin-bottom: 10px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .filter-bar label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      font-weight: 500;
    }

    .filter-bar input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--instagram-pink);
    }

    /* Reactions */
    .reactions {
      display: flex;
      gap: 15px;
      padding: 12px 15px;
      background: #ffffff;
      border-top: 1px solid #e9ecef;
      justify-content: flex-start;
      align-items: center;
    }

    .reaction {
      font-size: 1.4rem;
      cursor: pointer;
      transition: all 0.3s ease;
      padding: 8px;
      border-radius: 50%;
      position: relative;
      user-select: none;
    }

    .reaction:hover {
      transform: scale(1.2);
      background: rgba(0, 0, 0, 0.05);
    }

    .reaction.active {
      transform: scale(1.3);
      background: rgba(255, 107, 107, 0.1);
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
    }

    .reaction.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 4px;
      background: var(--instagram-pink);
      border-radius: 50%;
    }

    /* Dark Mode */
    body.dark-mode {
      background: #1a1a1a;
      color: #ffffff;
    }

    body.dark-mode .card {
      background: #2d2d2d;
      color: #ffffff;
      border: 1px solid #404040;
    }

    body.dark-mode .card p {
      color: #ffffff;
    }

    body.dark-mode .top-bar,
    body.dark-mode .bottom-nav,
    body.dark-mode .filter-bar {
      background: #2d2d2d;
      color: #ffffff;
      border: 1px solid #404040;
    }

    body.dark-mode .filter-bar label {
      color: #ffffff;
    }

    body.dark-mode .leaderboard-entry .player-name {
      color: #ffffff;
    }

    body.dark-mode .upload-section {
      color: #ffffff;
    }

    body.dark-mode .add-photo-btn {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: #ffffff;
    }

    body.dark-mode .photo-loading,
    body.dark-mode .photo-error {
      color: #ffffff;
    }

    body.dark-mode .reactions {
      background: #2d2d2d;
      border-top: 1px solid #555555;
    }

    body.dark-mode .reaction {
      color: #ffffff;
    }

    body.dark-mode .reaction:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .reaction.active {
      background: rgba(255, 107, 107, 0.2);
    }

    /* Confetti Animation */
    .confetti {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3000;
    }

    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 10px;
      background: var(--instagram-pink);
      animation: confetti-fall 3s linear infinite;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <!-- Clean Top Bar - Players Only -->
  <div class="top-bar">
    <div class="player-scroll" id="playerScroll">
      <!-- Player circles will be dynamically added here -->
    </div>
  </div>

  <!-- Event Banner -->
  <div class="event-banner" id="eventBanner" style="display: none;">
    <div class="event-banner-info">
      <div class="event-banner-title" id="eventBannerTitle">Event Name</div>
      <div class="event-banner-code" id="eventBannerCode">Code: EVENT123</div>
    </div>
    <div style="display: flex; gap: 10px; align-items: center;">
      <button id="addPlayerTopBtn" title="Add new player" style="display:inline-flex; align-items:center; justify-content:center; gap:6px; padding: 6px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.3); color: white; background: rgba(255,255,255,0.1); font-weight: 600; cursor: pointer; font-size: 0.85rem; transition: all 0.2s ease;">
        + Add Player
      </button>
      <a href="info.html" class="event-banner-link">Change Event</a>
    </div>
  </div>

  <!-- Main Content Area -->
  <div class="main-content">
    <!-- Filter Bar -->
    <div class="filter-bar">
      <label>
        <input type="checkbox" id="showCompletedOnly" onchange="toggleCompleted()">
        Show completed squares
      </label>
      <label>
        <input type="checkbox" id="showOutstandingOnly" onchange="toggleOutstanding()">
        Show outstanding squares
      </label>
    </div>
    
    <!-- Bingo Grid -->
    <div class="grid" id="bingoGrid"></div>
  </div>

  <!-- Bottom Navigation -->
  <div class="bottom-nav">
    <div class="nav-icon active" onclick="goHome()">üè†</div>
    <div class="nav-icon" onclick="openBoard()">üéØ</div>
    <div class="nav-icon" onclick="openLeaderboard()">ü•á</div>
    <div class="nav-icon" onclick="shareBingo()">üì§</div>
    <a href="info.html" class="nav-icon">‚ÑπÔ∏è</a>
    <div class="nav-icon" onclick="toggleDarkMode()">üåì</div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="leaderboardModal" class="modal">
    <div class="leaderboard-content">

      <div class="leaderboard-header">
        <h2>üéÜ Bingo Boss Hall of Fame üéÜ</h2>
        <p>Celebrating our photo challenge champions!</p>
      </div>
      <div id="leaderboardList" class="leaderboard-list">
        <!-- Leaderboard entries will be populated here -->
      </div>
      <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
        <button class="celebrate-button" onclick="celebrateLeaderboard()">
          üéâ Celebrate! üéâ
        </button>
        <button class="celebrate-button" onclick="closeLeaderboard()" style="background: linear-gradient(135deg, #6b7280, #9ca3af);">
          Close
        </button>
      </div>
    </div>
  </div>

  <div class="loading-spinner" id="loadingSpinner">
    <div class="spinner-container">
      <div class="spinner"></div>
      <span>Loading...</span>
    </div>
  </div>

  <!-- Page Loading Overlay -->
  <div class="page-loading hidden" id="pageLoading">
    <div class="page-spinner"></div>
    <div class="page-loading-text">Loading EventBingo...</div>
  </div>

  <script>
    function escapeQuotes(str) {
      return str.replace(/'/g, "\\'");
    }

    // Photo compression function
    async function compressImage(file) {
      return new Promise((resolve) => {
        // Check if browser supports canvas and required APIs
        if (!window.HTMLCanvasElement || !window.CanvasRenderingContext2D) {
          console.warn('Canvas not supported, using original file');
          resolve(file);
          return;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx || !canvas.toBlob) {
          console.warn('Canvas context or toBlob not supported, using original file');
          resolve(file);
          return;
        }

        const img = new Image();
        
        img.onload = function() {
          try {
            // Calculate new dimensions while maintaining aspect ratio
            let { width, height } = img;
            const maxWidth = COMPRESSION_CONFIG.maxWidth;
            const maxHeight = COMPRESSION_CONFIG.maxHeight;
            
            if (width > height) {
              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }
            } else {
              if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
              }
            }
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Draw and compress
            ctx.drawImage(img, 0, 0, width, height);
            
            // Convert to blob
            canvas.toBlob(
              (blob) => {
                if (blob && blob.size < file.size) {
                  // Only use compressed version if it's actually smaller
                  resolve(blob);
                } else {
                  // If compression didn't help, use original
                  resolve(file);
                }
              },
              COMPRESSION_CONFIG.format,
              COMPRESSION_CONFIG.quality
            );
          } catch (error) {
            console.warn('Compression failed:', error);
            resolve(file);
          }
        };
        
        img.onerror = function() {
          console.warn('Image load failed, using original file');
          resolve(file);
        };
        
        img.src = URL.createObjectURL(file);
      });
    }

    // Upload both compressed and original images
    async function uploadImages(originalFile, compressedFile, player, squareIndex, eventCode) {
      try {
        // Upload compressed version first (for immediate display)
        const compressedFormData = new FormData();
        compressedFormData.append("photo", compressedFile);
        compressedFormData.append("player", player);
        compressedFormData.append("square", squareIndex);
        compressedFormData.append("eventCode", eventCode);
        compressedFormData.append("type", "compressed");
        
        // Add authentication if available
        if (currentPlayerSecret) {
          compressedFormData.append("secretAnswer", currentPlayerSecret);
        }
        
        const compressedResponse = await fetch(`${workerURL}upload`, { 
          method: "POST", 
          body: compressedFormData 
        });
        
        // Only upload original if it's different from compressed (i.e., compression actually happened)
        if (originalFile !== compressedFile) {
          // Upload original in background (don't wait for it)
          const originalFormData = new FormData();
          originalFormData.append("photo", originalFile);
          originalFormData.append("player", player);
          originalFormData.append("square", squareIndex);
          originalFormData.append("eventCode", eventCode);
          originalFormData.append("type", "original");
          
          // Background upload - don't await
          fetch(`${workerURL}upload`, { 
            method: "POST", 
            body: originalFormData 
          }).catch(err => {
            console.warn('Background original upload failed:', err);
          });
        }
        
        return compressedResponse;
      } catch (error) {
        console.error('Upload failed:', error);
        throw error;
      }
    }

    // Default squares for events without custom squares
    const defaultSquaresList = [
      "'n Ou foto saam met Anneke",
      "'n Foto van 'n vorige verjaarsdag of braai",
      "Die oudste selfie wat julle saam het",
      "Anneke wat kaalvoet loop (bonus: vuil voete)",
      "Anneke wat 'n bier drink (bonus: cheers oomblik)",
      "Iemand wat iets by Anneke leen",
      "Oliver wat saam met iemand bal speel",
      "Kesia saam met 'n 'tannie' of 'oom'",
      "Almal bymekaar om die kampvuur",
      "Anneke wat in vrede sit en lees",
      "Oggendkoffie in 'n beker wat nie aan jou behoort nie",
      "Oliver wat 'help' met iets",
      "'n Foto van die sonsondergang",
      "Iemand wat sukkel met kamp opslaan",
      "Anneke se lag vasgevang in 'n spontane foto",
      "'n Kamp speletjie of aktiwiteit",
      "'n Kreatiewe foto van bier of koffie (bonus: albei)",
      "Oliver op sy fiets",
      "'n Groepsfoto van almal",
      "Iemand wat iets soek wat verlore is (bv. foon, skoen, drankie)",
      "'n Foto wat gewys iets is geleen vir kamp",
      "Oliver wat iets in tee doop",
      "Anneke wat ontspan met 'n boek",
      "Kesia wat glimlag",
      "Almal wat totsiens waai by die vuir"
    ];

    let squares = [];



    const workerURL = "https://shy-recipe-5fb1.reinier-olivier.workers.dev/";
    
    // Photo compression settings - adjust these for optimal quality/performance balance
    const COMPRESSION_CONFIG = {
      maxWidth: 1200,
      maxHeight: 1200,
      quality: 0.85, // 85% quality - adjust between 0.7-0.95 for testing
      format: 'image/jpeg'
    };

    // Authentication Manager - handles player authentication and localStorage operations
    class AuthManager {
      constructor() {
        this.isLocalStorageAvailable = this.checkLocalStorageAvailability();
      }

      // Check if localStorage is available
      checkLocalStorageAvailability() {
        try {
          const test = '__localStorage_test__';
          localStorage.setItem(test, test);
          localStorage.removeItem(test);
          return true;
        } catch (e) {
          console.warn('localStorage not available, authentication will be session-only');
          return false;
        }
      }

      // Generate localStorage keys
      getAnswerKey(eventCode, playerName) {
        return `secret_answer_${eventCode}_${playerName}`;
      }

      getVerifiedKey(eventCode, playerName) {
        return `secret_verified_${eventCode}_${playerName}`;
      }

      getTimestampKey(eventCode, playerName) {
        return `secret_timestamp_${eventCode}_${playerName}`;
      }

      // Check if player has local authentication
      hasLocalAuth(eventCode, playerName) {
        if (!this.isLocalStorageAvailable) return false;
        
        try {
          const answerKey = this.getAnswerKey(eventCode, playerName);
          const verifiedKey = this.getVerifiedKey(eventCode, playerName);
          
          return localStorage.getItem(answerKey) && localStorage.getItem(verifiedKey) === 'true';
        } catch (e) {
          console.warn('Error checking local auth:', e);
          return false;
        }
      }

      // Get stored answer for auto-verification
      getStoredAnswer(eventCode, playerName) {
        if (!this.isLocalStorageAvailable) return null;
        
        try {
          const answerKey = this.getAnswerKey(eventCode, playerName);
          return localStorage.getItem(answerKey);
        } catch (e) {
          console.warn('Error getting stored answer:', e);
          return null;
        }
      }

      // Store authentication data locally
      storeAuth(eventCode, playerName, answer) {
        if (!this.isLocalStorageAvailable) {
          console.warn('Cannot store auth data - localStorage unavailable');
          return false;
        }
        
        try {
          const answerKey = this.getAnswerKey(eventCode, playerName);
          const verifiedKey = this.getVerifiedKey(eventCode, playerName);
          const timestampKey = this.getTimestampKey(eventCode, playerName);
          
          localStorage.setItem(answerKey, answer.toLowerCase().trim().replace(/\s+/g, ' '));
          localStorage.setItem(verifiedKey, 'true');
          localStorage.setItem(timestampKey, Date.now().toString());
          
          return true;
        } catch (e) {
          console.warn('Error storing auth data:', e);
          return false;
        }
      }

      // Clear local authentication
      clearAuth(eventCode, playerName) {
        if (!this.isLocalStorageAvailable) return;
        
        try {
          const answerKey = this.getAnswerKey(eventCode, playerName);
          const verifiedKey = this.getVerifiedKey(eventCode, playerName);
          const timestampKey = this.getTimestampKey(eventCode, playerName);
          
          localStorage.removeItem(answerKey);
          localStorage.removeItem(verifiedKey);
          localStorage.removeItem(timestampKey);
        } catch (e) {
          console.warn('Error clearing auth data:', e);
        }
      }

      // Verify current authentication state
      isAuthenticated(eventCode, playerName) {
        return this.hasLocalAuth(eventCode, playerName);
      }

      // Clean up old authentication data (optional maintenance)
      cleanupOldAuth(maxAge = 30 * 24 * 60 * 60 * 1000) { // 30 days default
        if (!this.isLocalStorageAvailable) return;
        
        try {
          const now = Date.now();
          const keysToRemove = [];
          
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('secret_timestamp_')) {
              const timestamp = parseInt(localStorage.getItem(key));
              if (now - timestamp > maxAge) {
                // Mark related keys for removal
                const parts = key.replace('secret_timestamp_', '').split('_');
                const eventCode = parts[0];
                const playerName = parts.slice(1).join('_');
                
                keysToRemove.push(this.getAnswerKey(eventCode, playerName));
                keysToRemove.push(this.getVerifiedKey(eventCode, playerName));
                keysToRemove.push(key);
              }
            }
          }
          
          keysToRemove.forEach(key => localStorage.removeItem(key));
          
          if (keysToRemove.length > 0) {
            console.log(`Cleaned up ${keysToRemove.length / 3} old authentication entries`);
          }
        } catch (e) {
          console.warn('Error during auth cleanup:', e);
        }
      }
    }

    // Initialize authentication manager
    const authManager = new AuthManager();
    
    // Clean up old authentication data on startup
    authManager.cleanupOldAuth();

    // Authentication functions
    async function registerNewPlayer(playerName, answer) {
      try {
        // Normalize answer before sending (for consistency)
        const normalizedAnswer = answer.toLowerCase().trim().replace(/\s+/g, ' ');
        
        console.log('Registering player:', playerName, 'with answer:', normalizedAnswer);
        
        const response = await fetch(`${workerURL}auth/register`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            eventCode: eventCode,
            playerName: playerName,
            answer: normalizedAnswer
          })
        });

        const data = await response.json();
        
        if (data.success) {
          // Store authentication locally
          authManager.storeAuth(eventCode, playerName, normalizedAnswer);
          currentPlayerSecret = normalizedAnswer;
          isAuthenticated = true;
          isViewOnlyMode = false;
          
          return { success: true, question: data.question };
        } else {
          return { success: false, message: data.message || 'Registration failed' };
        }
      } catch (error) {
        console.error('Registration error:', error);
        return { success: false, message: 'Network error during registration' };
      }
    }

    async function verifyPlayerAuthentication(playerName, answer) {
      try {
        // Normalize answer before sending (for consistency)
        const normalizedAnswer = answer.toLowerCase().trim().replace(/\s+/g, ' ');
        
        console.log('Verifying player:', playerName, 'with answer:', normalizedAnswer);
        
        const response = await fetch(`${workerURL}auth/verify`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            eventCode: eventCode,
            playerName: playerName,
            answer: normalizedAnswer
          })
        });

        const data = await response.json();
        
        if (data.success && data.authenticated) {
          // Store authentication locally
          authManager.storeAuth(eventCode, playerName, normalizedAnswer);
          currentPlayerSecret = normalizedAnswer;
          isAuthenticated = true;
          isViewOnlyMode = false;
          
          return { success: true, authenticated: true };
        } else {
          // Authentication failed - enter view-only mode
          currentPlayerSecret = null;
          isAuthenticated = false;
          isViewOnlyMode = true;
          
          return { success: true, authenticated: false, message: data.message };
        }
      } catch (error) {
        console.error('Verification error:', error);
        // On network error, allow view-only mode
        currentPlayerSecret = null;
        isAuthenticated = false;
        isViewOnlyMode = true;
        
        return { success: false, message: 'Network error during verification' };
      }
    }

    async function getPlayerQuestion(playerName) {
      try {
        const response = await fetch(`${workerURL}auth/question/${eventCode}/${encodeURIComponent(playerName)}`);
        
        if (response.ok) {
          const data = await response.json();
          return { success: true, question: data.question };
        } else {
          return { success: false, message: 'Player not found' };
        }
      } catch (error) {
        console.error('Error getting question:', error);
        return { success: false, message: 'Network error' };
      }
    }

    // Set authentication state for a player
    function setPlayerAuthentication(playerName) {
      // Check if we have local authentication
      if (authManager.hasLocalAuth(eventCode, playerName)) {
        currentPlayerSecret = authManager.getStoredAnswer(eventCode, playerName);
        isAuthenticated = true;
        isViewOnlyMode = false;
        return 'authenticated';
      } else {
        currentPlayerSecret = null;
        isAuthenticated = false;
        isViewOnlyMode = true;
        return 'needs_auth';
      }
    }

    // Update UI based on authentication state
    function updateUIForAuthState() {
      const uploadSections = document.querySelectorAll('.upload-section');
      const addPhotoButtons = document.querySelectorAll('.add-photo-btn');
      
      if (isViewOnlyMode) {
        // Hide upload UI elements
        uploadSections.forEach(section => {
          section.style.display = 'none';
        });
        
        // Show view-only message if not already shown
        if (!document.getElementById('viewOnlyMessage')) {
          const message = document.createElement('div');
          message.id = 'viewOnlyMessage';
          message.style.cssText = `
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            z-index: 1000;
            font-weight: 600;
            text-align: center;
            max-width: 90%;
            font-size: 0.9rem;
          `;
          message.innerHTML = `
            üëÄ View-Only Mode<br>
            <small style="font-size: 0.8rem; opacity: 0.9;">You can view ${currentPlayer}'s photos but cannot upload for ${currentPlayer}</small>
          `;
          document.body.appendChild(message);
          
          // Auto-hide after 5 seconds
          setTimeout(() => {
            if (message.parentNode) {
              message.parentNode.removeChild(message);
            }
          }, 5000);
        }
      } else {
        // Show upload UI elements
        uploadSections.forEach(section => {
          section.style.display = 'block';
        });
        
        // Remove view-only message if present
        const existingMessage = document.getElementById('viewOnlyMessage');
        if (existingMessage && existingMessage.parentNode) {
          existingMessage.parentNode.removeChild(existingMessage);
        }
      }
    }
    
    const grid = document.getElementById("bingoGrid");
    const playerScroll = document.getElementById("playerScroll");
    const loadingSpinner = document.getElementById("loadingSpinner");
    const carouselModal = document.getElementById("carouselModal");
    const carouselImage = document.getElementById("carouselImage");
    const carouselCaption = document.getElementById("carouselCaption");

    let currentPlayer = "";
    let allPhotos = [];
    let isDarkMode = false;
    let isMusicPlaying = false;
    let currentEvent = null;
    let hasPromptedForPlayer = false;
    
    // Authentication state
    let isAuthenticated = false;
    let isViewOnlyMode = false;
    let currentPlayerSecret = null;
    const params = new URLSearchParams(window.location.search);
    let eventCode = params.get("event") || "default";

    // Helper function to generate Bingo-related icons for players
    // Global cache to track used icons and prevent duplicates
    window.playerIconCache = window.playerIconCache || new Map();
    
    function getPlayerIcon(name) {
      const bingoIcons = [
        'üéØ', 'üé≤', 'üé™', 'üé®', 'üé≠', 'üé∏', 'üé∫', 'üéª', 
        'üéÆ', 'üé≥', 'üé∞', 'üéä', 'üéâ', 'üéà', 'üéÅ', 'üéÄ',
        'üèÜ', 'üèÖ', 'ü•á', 'ü•à', 'ü•â', '‚≠ê', 'üåü', '‚ú®',
        'üî•', 'üíé', 'üëë', 'üéñÔ∏è', 'üèµÔ∏è', 'üéóÔ∏è', 'üé´', 'üéüÔ∏è'
      ];
      
      if (!name) return '‚ùì';
      
      // Check if we already have an icon for this player
      if (window.playerIconCache.has(name)) {
        return window.playerIconCache.get(name);
      }
      
      // Create a hash based on the player's name
      let hash = 0;
      const cleanName = name.toLowerCase().trim();
      
      for (let i = 0; i < cleanName.length; i++) {
        const char = cleanName.charCodeAt(i);
        hash = ((hash << 5) - hash + char) & 0xffffffff;
      }
      
      // Add some additional entropy based on name characteristics
      const nameLength = cleanName.length;
      const firstChar = cleanName.charCodeAt(0) || 0;
      const lastChar = cleanName.charCodeAt(nameLength - 1) || 0;
      
      // Try to find an unused icon
      let attempts = 0;
      let selectedIcon;
      const usedIcons = new Set(window.playerIconCache.values());
      
      do {
        const combinedHash = Math.abs(hash + nameLength * 7 + firstChar * 13 + lastChar * 17 + attempts * 23);
        const iconIndex = combinedHash % bingoIcons.length;
        selectedIcon = bingoIcons[iconIndex];
        attempts++;
      } while (usedIcons.has(selectedIcon) && attempts < bingoIcons.length);
      
      // If all icons are used, just use the hash-based selection
      if (attempts >= bingoIcons.length) {
        const combinedHash = Math.abs(hash + nameLength * 7 + firstChar * 13 + lastChar * 17);
        const iconIndex = combinedHash % bingoIcons.length;
        selectedIcon = bingoIcons[iconIndex];
      }
      
      // Cache the result
      window.playerIconCache.set(name, selectedIcon);
      return selectedIcon;
    }

    // Instagram-style functions
    function selectPlayer(playerName) {
      currentPlayer = playerName;
      
      // Set authentication state
      const authState = setPlayerAuthentication(playerName);
      
      // Save last player for this event
      try { 
        localStorage.setItem(`eventbingo:lastPlayer:${eventCode}`, playerName);
        localStorage.setItem('eventbingo:currentPlayer', playerName); // Global current player
      } catch(_) {}
      
      updatePlayerCircles();
      createGrid();
      loadPhotos(currentPlayer);
      updateUIForAuthState();
      
      // Ensure the selected player is visible in the top bar immediately
      loadPlayers();
    }

    function updatePlayerCircles() {
      playerScroll.innerHTML = "";
      // This will be populated when we load players
    }

    function toggleReaction(index, emoji) {
      const reactionsContainer = document.querySelector(`#reactions${index}`);
      const reaction = reactionsContainer.querySelector(`.reaction[onclick*="${emoji}"]`);
      
      if (!reaction) return;
      
      // Instagram-like behavior: only one reaction can be active at a time
      const allReactions = reactionsContainer.querySelectorAll('.reaction');
      allReactions.forEach(r => r.classList.remove('active'));
      
      // Toggle the clicked reaction
      reaction.classList.add('active');
      
      // Add a bounce animation
      reaction.style.transform = 'scale(1.5)';
      setTimeout(() => {
        reaction.style.transform = 'scale(1.3)';
      }, 150);
      
      // Save reaction to localStorage (optional persistence)
      try {
        const reactionKey = `eventbingo:reaction:${eventCode}:${index}`;
        localStorage.setItem(reactionKey, emoji);
      } catch(_) {}
    }

    function checkForCompletion() {
      const completedCards = document.querySelectorAll('.card.completed').length;
      
      // Ensure squares array is valid for completion check
      const totalSquares = (squares && squares.length > 0) ? squares.length : 25;
      
      if (completedCards === totalSquares) {
        showConfetti();
        alert('üéâ Congratulations! You completed all squares! üéâ');
      }
    }

    function shareBingo() {
      const url = window.location.href;
      if (navigator.share) {
        navigator.share({
          title: 'EventBingo!!',
          text: 'Check out my EventBingo progress!',
          url: url
        });
      } else {
        navigator.clipboard.writeText(url).then(() => {
          alert('Link copied to clipboard!');
        });
      }
    }

    function goHome() {
      setActiveNavIcon(0);
      // Already on home view
    }


    function openBoard() {
      // Navigate to the board page with current player context
      const boardUrl = currentPlayer 
        ? `board.html?event=${encodeURIComponent(eventCode)}&player=${encodeURIComponent(currentPlayer)}`
        : `board.html?event=${encodeURIComponent(eventCode)}`;
      window.location.href = boardUrl;
    }

    function openLeaderboard() {
      setActiveNavIcon(3);
      showLeaderboard();
    }

    function showLeaderboard() {
      const leaderboardModal = document.getElementById('leaderboardModal');
      leaderboardModal.classList.add('show');
      loadLeaderboardData();
    }

    function closeLeaderboard() {
      const leaderboardModal = document.getElementById('leaderboardModal');
      leaderboardModal.classList.remove('show');
    }

    async function loadLeaderboardData() {
      const leaderboardList = document.getElementById('leaderboardList');
      
      try {
        // Show modal loading in the leaderboard
        showModalLoading(leaderboardList, "Loading Hall of Fame...");
        
        const res = await fetch(`${workerURL}players?event=${eventCode}`);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const players = await res.json();
        
        // Sort players by count (descending)
        players.sort((a, b) => b.count - a.count);
        
        // Clear loading and populate leaderboard
        leaderboardList.innerHTML = '';
        
        if (players.length === 0) {
          leaderboardList.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #e0e0e0;">
              <div style="font-size: 4rem; margin-bottom: 20px;">üé≤</div>
              <h3 style="color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">No Bingo Bosses Yet!</h3>
              <p>Start snapping photos to join the Hall of Fame!</p>
            </div>
          `;
          return;
        }
        
        players.forEach((player, index) => {
          const entry = document.createElement('div');
          entry.className = 'leaderboard-entry';
          
          // Add special styling for top 3
          if (index === 0) entry.classList.add('first');
          else if (index === 1) entry.classList.add('second');
          else if (index === 2) entry.classList.add('third');
          
          // Bingo gaming titles
          let title = '';
          if (index === 0) title = 'üéØ Bingo Boss Supreme';
          else if (index === 1) title = '‚≠ê Photo Master';
          else if (index === 2) title = 'üèÖ Challenge Champion';
          else if (player.count >= 20) title = 'üî• Hot Streak Player';
          else if (player.count >= 15) title = 'üì∏ Photo Pro';
          else if (player.count >= 10) title = 'üé™ Rising Star';
          else if (player.count >= 5) title = 'üåü Getting Started';
          else title = 'üé≤ New Player';
          
          entry.innerHTML = `
            <div class="rank">${getRankEmoji(index + 1)}</div>
            <div class="player-info">
              <div class="player-avatar">${getPlayerIcon(player.name)}</div>
              <div class="player-details">
                <div class="player-name">${player.name}</div>
                <div class="player-title">${title}</div>
              </div>
            </div>
          `;
          
          leaderboardList.appendChild(entry);
        });
        
      } catch (err) {
        
        const leaderboardList = document.getElementById('leaderboardList');
        leaderboardList.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #ff6b6b;">
            <div style="font-size: 4rem; margin-bottom: 20px;">‚ö†Ô∏è</div>
            <h3 style="color: #ffd700;">Oops! Something went wrong</h3>
            <p>Please try again later, Bingo Boss!</p>
          </div>
        `;
      } finally {
        hideLoading();
      }
    }

    function getRankEmoji(rank) {
      if (rank === 1) return 'üëë';
      if (rank === 2) return 'ü•à';
      if (rank === 3) return 'ü•â';
      if (rank <= 5) return 'üèÜ';
      if (rank <= 10) return 'üéñÔ∏è';
      return 'üéØ';
    }

    function celebrateLeaderboard() {
      // Trigger confetti
      showConfetti();
      
      // Add fireworks effect
      createFireworks();
      
      // Play celebration sound (if available)
      playCelebrationSound();
    }

    function createFireworks() {
      const leaderboardContent = document.querySelector('.leaderboard-content');
      const fireworks = document.createElement('div');
      fireworks.className = 'fireworks';
      
      // Create multiple fireworks
      for (let i = 0; i < 20; i++) {
        const firework = document.createElement('div');
        firework.className = 'firework';
        firework.style.left = Math.random() * 100 + '%';
        firework.style.top = Math.random() * 100 + '%';
        firework.style.backgroundColor = ['#ffd700', '#ff6b6b', '#4a90e2', '#51cf66', '#ff8e8e'][Math.floor(Math.random() * 5)];
        firework.style.animationDelay = Math.random() * 2 + 's';
        fireworks.appendChild(firework);
      }
      
      leaderboardContent.appendChild(fireworks);
      
      // Remove fireworks after animation
      setTimeout(() => {
        if (fireworks.parentNode) {
          fireworks.parentNode.removeChild(fireworks);
        }
      }, 3000);
    }

    function playCelebrationSound() {
      // Create a simple celebration sound using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (err) {
        
      }
    }

    function toggleDarkMode() {
      isDarkMode = !isDarkMode;
      document.body.classList.toggle('dark-mode', isDarkMode);
      setActiveNavIcon(isDarkMode ? 3 : -1);
    }

    function toggleMusic() {
      isMusicPlaying = !isMusicPlaying;
      setActiveNavIcon(isMusicPlaying ? 4 : -1);
      // Could implement background music here
      
    }

    function setActiveNavIcon(index) {
      document.querySelectorAll('.nav-icon').forEach((icon, i) => {
        icon.classList.toggle('active', i === index);
      });
    }

    // Remove search from nav icon indices
    function goHome() {
      setActiveNavIcon(0);
    }

    function openBoard() {
      // Navigate to the board page with current player context
      const boardUrl = currentPlayer 
        ? `board.html?event=${encodeURIComponent(eventCode)}&player=${encodeURIComponent(currentPlayer)}`
        : `board.html?event=${encodeURIComponent(eventCode)}`;
      window.location.href = boardUrl;
    }

    function openLeaderboard() {
      setActiveNavIcon(2);
      showLeaderboard();
    }

    function showCarousel() {
      const carouselModal = document.getElementById('carouselModal');
      carouselModal.classList.add('show');
      
      // Show loading in carousel
      const carouselContent = carouselModal.querySelector('.carousel-content') || carouselModal;
      showModalLoading(carouselContent, "Loading photo gallery...");
      
      // Load all photos for carousel with a slight delay for better UX
      setTimeout(() => {
        loadAllPhotosForCarousel();
      }, 300);
    }

    function closeCarousel() {
      carouselModal.classList.remove('show');
    }

    function loadAllPhotosForCarousel() {
      // Collect all uploaded photos from the current view
      const allImages = document.querySelectorAll('.card-photo img');
      const photos = [];
      
      allImages.forEach((img, index) => {
        if (img.src && img.src !== '') {
          photos.push({
            src: img.src,
            alt: img.alt || `Photo ${index + 1}`,
            caption: img.alt || `Photo ${index + 1}`
          });
        }
      });
      
      if (photos.length === 0) {
        carouselCaption.textContent = 'No photos uploaded yet. Start completing challenges to see them here!';
        carouselImage.style.display = 'none';
        return;
      }
      
      // Show first photo
      let currentPhotoIndex = 0;
      showPhotoInCarousel(photos[currentPhotoIndex]);
      
      // Add navigation controls
      carouselContent.innerHTML = `
        <div class="carousel-close" onclick="closeCarousel()">√ó</div>
        <div class="carousel-nav">
          <button class="carousel-prev" onclick="previousPhoto()" ${photos.length <= 1 ? 'style="display:none"' : ''}>‚Äπ</button>
          <button class="carousel-next" onclick="nextPhoto()" ${photos.length <= 1 ? 'style="display:none"' : ''}>‚Ä∫</button>
        </div>
        <img id="carouselImage" class="carousel-image" src="" alt="">
        <div id="carouselCaption"></div>
        <div class="carousel-counter">${currentPhotoIndex + 1} / ${photos.length}</div>
      `;
      
      // Update references after recreating elements
      carouselImage = document.getElementById('carouselImage');
      carouselCaption = document.getElementById('carouselCaption');
      
      // Global variables for navigation
      window.carouselPhotos = photos;
      window.currentPhotoIndex = currentPhotoIndex;
      
      function showPhotoInCarousel(photo) {
        carouselImage.src = photo.src;
        carouselImage.alt = photo.alt;
        carouselCaption.textContent = photo.caption;
        carouselImage.style.display = 'block';
      }
      
      // Navigation functions
      window.nextPhoto = function() {
        if (window.carouselPhotos && window.carouselPhotos.length > 1) {
          window.currentPhotoIndex = (window.currentPhotoIndex + 1) % window.carouselPhotos.length;
          showPhotoInCarousel(window.carouselPhotos[window.currentPhotoIndex]);
          updateCounter();
        }
      };
      
      window.previousPhoto = function() {
        if (window.carouselPhotos && window.carouselPhotos.length > 1) {
          window.currentPhotoIndex = (window.currentPhotoIndex - 1 + window.carouselPhotos.length) % window.carouselPhotos.length;
          showPhotoInCarousel(window.carouselPhotos[window.currentPhotoIndex]);
          updateCounter();
        }
      };
      
      function updateCounter() {
        const counter = document.querySelector('.carousel-counter');
        if (counter) {
          counter.textContent = `${window.currentPhotoIndex + 1} / ${window.carouselPhotos.length}`;
        }
      }
      
      // Keyboard navigation
      document.addEventListener('keydown', function(e) {
        if (carouselModal.classList.contains('show')) {
          if (e.key === 'ArrowLeft') previousPhoto();
          if (e.key === 'ArrowRight') nextPhoto();
          if (e.key === 'Escape') closeCarousel();
        }
      });
    }

    function toggleCompleted() {
      const showCompletedOnly = document.getElementById('showCompletedOnly').checked;
      const showOutstandingOnly = document.getElementById('showOutstandingOnly');
      
      // If completed is checked, uncheck outstanding
      if (showCompletedOnly) {
        showOutstandingOnly.checked = false;
      }
      
      const cards = document.querySelectorAll('.card');
      
      cards.forEach(card => {
        const hasPhoto = card.querySelector('img');
        if (showCompletedOnly) {
          card.style.display = hasPhoto ? 'block' : 'none';
        } else {
          card.style.display = 'block';
        }
      });
    }

    function toggleOutstanding() {
      const showOutstandingOnly = document.getElementById('showOutstandingOnly').checked;
      const showCompletedOnly = document.getElementById('showCompletedOnly');
      
      // If outstanding is checked, uncheck completed
      if (showOutstandingOnly) {
        showCompletedOnly.checked = false;
      }
      
      const cards = document.querySelectorAll('.card');
      
      cards.forEach(card => {
        const hasPhoto = card.querySelector('img');
        if (showOutstandingOnly) {
          card.style.display = hasPhoto ? 'none' : 'block';
        } else {
          card.style.display = 'block';
        }
      });
    }

    function showConfetti() {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      
      for (let i = 0; i < 50; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.left = Math.random() * 100 + '%';
        piece.style.animationDelay = Math.random() * 3 + 's';
        piece.style.backgroundColor = ['#E4405F', '#833AB4', '#F77737', '#FCAF45'][Math.floor(Math.random() * 4)];
        confetti.appendChild(piece);
      }
      
      document.body.appendChild(confetti);
      setTimeout(() => confetti.remove(), 3000);
    }

    function showLoading(message = "Loading...") {
      const spinner = document.getElementById("loadingSpinner");
      const text = spinner.querySelector("span");
      if (text) text.textContent = message;
      spinner.style.display = "flex";
    }

    function hideLoading() {
      const spinner = document.getElementById("loadingSpinner");
      spinner.style.display = "none";
    }

    function showPageLoading(message = "Loading EventBingo...") {
      const pageLoading = document.getElementById("pageLoading");
      const text = pageLoading.querySelector(".page-loading-text");
      if (text) text.textContent = message;
      pageLoading.classList.remove("hidden");
    }

    function hidePageLoading() {
      const pageLoading = document.getElementById("pageLoading");
      pageLoading.classList.add("hidden");
    }

    function showModalLoading(container, message = "Loading...") {
      container.innerHTML = `
        <div class="modal-loading">
          <div class="modal-spinner"></div>
          <div style="color: #ffffff; font-weight: 600;">${message}</div>
        </div>
      `;
    }

    function showInlineLoading(container, message = "Loading...") {
      container.innerHTML = `
        <div class="inline-loading">
          <div class="inline-spinner"></div>
          <span>${message}</span>
        </div>
      `;
    }

    function setButtonLoading(button, isLoading) {
      if (isLoading) {
        button.classList.add("button-loading");
        button.disabled = true;
      } else {
        button.classList.remove("button-loading");
        button.disabled = false;
      }
    }

    function createGrid() {
      // Ensure we have valid squares before creating grid
      if (!squares || squares.length === 0) {
        console.warn('No squares available for grid creation, using default squares');
        squares = defaultSquaresList;
      }
      
      // Validate squares one more time before grid creation
      const validation = validateSquares(squares);
      if (!validation.valid) {
        console.warn('Invalid squares detected during grid creation:', validation.reason, 'Using default squares');
        squares = defaultSquaresList;
      }
      
      grid.innerHTML = "";
      squares.forEach((square, index) => {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div class="card-content">
            <p>${square}</p>
            <div class="upload-section" id="upload${index}">
              <button class="add-photo-btn" id="btn${index}">
                <span class="add-icon">+</span>
                <span class="add-text">Add Photo</span>
              </button>
              <input type="file" id="file${index}" accept="image/*" style="display: none;" />
            </div>
          </div>
          <div class="card-photo" id="result${index}"></div>
          <div class="reactions" id="reactions${index}">
            <span class="reaction" onclick="toggleReaction(${index}, '‚ù§Ô∏è')">‚ù§Ô∏è</span>
            <span class="reaction" onclick="toggleReaction(${index}, 'üòÇ')">üòÇ</span>
            <span class="reaction" onclick="toggleReaction(${index}, 'üî•')">üî•</span>
            <span class="reaction" onclick="toggleReaction(${index}, 'üôå')">üôå</span>
          </div>
        `;
        grid.appendChild(div);

        const fileInput = div.querySelector(`#file${index}`);
        const resultDiv = div.querySelector(`#result${index}`);
        const uploadSection = div.querySelector(`#upload${index}`);
        const addPhotoBtn = div.querySelector(`#btn${index}`);

        // Initially hide upload section if there's already a photo
        if (resultDiv.innerHTML.trim() !== "") {
          uploadSection.classList.add('hidden');
        }

        // Handle button click to trigger file input
        addPhotoBtn.addEventListener("click", () => {
          fileInput.click();
        });

        fileInput.addEventListener("change", async (e) => {
          if (!currentPlayer) {
            const selected = await promptForPlayerSelection();
            if (!selected) {
              e.target.value = ""; // Clear file input
              return;
            }
            currentPlayer = selected;
          }
          
          // Check if user is in view-only mode
          if (isViewOnlyMode) {
            alert(`You can view ${currentPlayer}'s photos but cannot upload for ${currentPlayer}. To upload photos, select your own name and authenticate.`);
            e.target.value = ""; // Clear file input
            return;
          }
          
          const file = e.target.files[0];
          if (!file) return;

          // Show loading states
          setButtonLoading(addPhotoBtn, true);
          resultDiv.innerHTML = '<div class="photo-loading">üì∏ Compressing photo...</div>';
          showLoading("Compressing and uploading your photo...");

          try {
            // Compress the image
            const compressedFile = await compressImage(file);
            
            // Debug info
            const originalSize = (file.size / 1024).toFixed(1);
            const compressedSize = (compressedFile.size / 1024).toFixed(1);
            const compressionRatio = ((1 - compressedFile.size / file.size) * 100).toFixed(1);
            
            console.log(`Photo compression: ${originalSize}KB ‚Üí ${compressedSize}KB (${compressionRatio}% reduction)`);
            
            // Update loading message
            resultDiv.innerHTML = '<div class="photo-loading">üì§ Uploading photo...</div>';
            
            // Upload both versions
            const res = await uploadImages(file, compressedFile, currentPlayer, index, eventCode);
            const data = await res.json();
            
            if (data.success && data.key) {
              const photoUrl = `${workerURL}photo/${data.key}`;
              resultDiv.innerHTML = `
                <img src="${photoUrl}" alt="Uploaded photo" onclick="window.open('${escapeQuotes(photoUrl)}', '_blank')" style="cursor: pointer; opacity:0; transition: opacity 0.3s ease;" onload="this.style.opacity='1'" />
              `;
              // Hide the upload section since photo is now loaded
              uploadSection.classList.add('hidden');
              div.classList.add('completed');
              updateProgress();
              updateLeaderboard();
              // Check if player completed all squares for confetti
              checkForCompletion();
              // Refresh player list to include new players and update progress table
              // Don't await to avoid blocking the UI
              loadPlayers().catch(() => {});
            } else {
              resultDiv.innerHTML = '<div class="photo-error">‚ùå Upload failed. Please try again.</div>';
            }
          } catch (err) {
            console.error('Upload error:', err);
            resultDiv.innerHTML = '<div class="photo-error">‚ùå Error uploading photo. Please try again.</div>';
          } finally {
            setButtonLoading(addPhotoBtn, false);
            hideLoading();
          }
        });
      });
      
      // Restore saved reactions
      squares.forEach((square, index) => {
        try {
          const reactionKey = `eventbingo:reaction:${eventCode}:${index}`;
          const savedReaction = localStorage.getItem(reactionKey);
          if (savedReaction) {
            const reactionsContainer = document.querySelector(`#reactions${index}`);
            const reaction = reactionsContainer.querySelector(`.reaction[onclick*="${savedReaction}"]`);
            if (reaction) {
              reaction.classList.add('active');
            }
          }
        } catch(_) {}
      });
    }

    async function loadPlayers() {
      try {
        showLoading("Loading players...");
        const res = await fetch(`${workerURL}players?event=${eventCode}`);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const players = await res.json();
        
        // Update player circles in top bar
        playerScroll.innerHTML = "";

        // Build a list including the current player (ensure appears even with 0 photos)
        const names = [...players.map(p => p.name)];
        if (currentPlayer && !names.includes(currentPlayer)) {
          players.unshift({ name: currentPlayer, count: 0 });
        }

        // Render players
        players.forEach((player, index) => {
          const playerItem = document.createElement("div");
          playerItem.className = "player-item";
          
          const circle = document.createElement("div");
          circle.className = "player-circle";
          circle.textContent = getPlayerIcon(player.name);
          circle.title = player.name;
          circle.onclick = () => selectPlayer(player.name);
          if (player.name === currentPlayer) {
            circle.classList.add('active');
          }
          
          const name = document.createElement("div");
          name.className = "player-name";
          name.textContent = player.name;
          
          playerItem.appendChild(circle);
          playerItem.appendChild(name);
          playerScroll.appendChild(playerItem);
        });
        // If no player selected yet and we haven't prompted on load, we rely on the on-load prompt
        
      } catch (err) {
        
      } finally {
        hideLoading();
      }
    }

    function updateProgressTable(players) {
      if (players.length === 0) {
        progressTable.style.display = "none";
        return;
      }
      
      progressTable.style.display = "block";
      progressList.innerHTML = "";
      
      // Sort players by count (descending)
      players.sort((a, b) => b.count - a.count);
      
      players.forEach(player => {
        const row = document.createElement("div");
        row.className = "progress-row";
        row.innerHTML = `
          <span class="progress-name">${player.name}</span>
          <span class="progress-count">${player.count}/${squares.length}</span>
        `;
        progressList.appendChild(row);
      });
    }

    async function loadPhotos(player) {
      try {
        showLoading();
        const res = await fetch(`${workerURL}player?name=${encodeURIComponent(player)}&event=${eventCode}`);
        const data = await res.json();
        squares.forEach((square, index) => {
          const resultDiv = document.getElementById(`result${index}`);
          const uploadSection = document.getElementById(`upload${index}`);
          const card = resultDiv.closest('.card');
          const url = data[square];
          if (url) {
            resultDiv.innerHTML = `
              <img src="${url}" alt="${escapeQuotes(square)}" onclick="window.open('${escapeQuotes(url)}', '_blank')" style="cursor: pointer; opacity:0; transition: opacity 0.3s ease;" onload="this.style.opacity='1'" />
            `;
            // Hide the upload section since photo is already loaded
            if (uploadSection) {
              uploadSection.classList.add('hidden');
            }
            // Mark card as completed
            if (card) {
              card.classList.add('completed');
            }
          } else {
            resultDiv.innerHTML = "";
            // Show the upload section if no photo is loaded
            if (uploadSection) {
              uploadSection.classList.remove('hidden');
            }
            // Remove completed class
            if (card) {
              card.classList.remove('completed');
            }
          }
        });
        updateProgress();
        // Refresh progress table after loading photos
        loadPlayers();
      } catch (err) {
        
        // Clear all photo displays on error
        squares.forEach((square, index) => {
          const resultDiv = document.getElementById(`result${index}`);
          resultDiv.innerHTML = "";
        });
      } finally {
        hideLoading();
      }
    }

    async function updateProgress() {
      const filled = [...document.querySelectorAll("[id^='result'] img")].length;
      
      // Ensure squares array is valid for progress calculation
      const totalSquares = (squares && squares.length > 0) ? squares.length : 25;
      
      // Note: progressDisplay element not in HTML - function kept for compatibility
      if (typeof progressDisplay !== 'undefined') {
        progressDisplay.textContent = `${currentPlayer} has completed ${filled} of ${totalSquares} squares.`;
      }
    }

    async function updateLeaderboard() {
      // Note: leaderDisplay element not in HTML - function kept for compatibility
      if (typeof leaderDisplay !== 'undefined') {
        const res = await fetch(`${workerURL}leader?event=${eventCode}`);
        const data = await res.json();
        leaderDisplay.textContent = data.name
          ? `üèÜ Leader: ${data.name} (${data.count}/${squares.length})`
          : "";
      }
    }

    // Prompt for player selection or new player
    async function promptForPlayerSelection() {
      return new Promise(async (resolve) => {
        try {
          // Fetch current players
          const res = await fetch(`${workerURL}players?event=${eventCode}`);
          const players = await res.json();
          
          // Create modal for player selection
          const modal = document.createElement("div");
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
          `;
          
          const content = document.createElement("div");
          const isDark = document.body.classList.contains('dark-mode');
          content.style.cssText = `
            background: ${isDark ? '#1f2937' : 'linear-gradient(135deg, rgba(255,255,255,0.98), rgba(255,255,255,0.95))'};
            color: ${isDark ? '#ffffff' : '#1f2937'};
            padding: 30px;
            border-radius: 20px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border: 2px solid rgba(228, 64, 95, 0.2);
          `;
          
          // Check for last player in localStorage
          let lastPlayer = '';
          try {
            lastPlayer = localStorage.getItem(`eventbingo:lastPlayer:${eventCode}`) || '';
          } catch (_) {}
          
          let html = `
            <h2 style="margin-top: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'} background: var(--story-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.5rem; margin-bottom: 20px;">Select a Player</h2>`;
          
          // Show "Continue as last player" if available
          if (lastPlayer) {
            html += `
              <div id="continueLastPlayer" style="
                padding: 15px;
                margin-bottom: 15px;
                background: linear-gradient(135deg, #10b981, #34d399);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
              " onclick="selectPlayerOption('${escapeQuotes(lastPlayer)}')">
                <div style="
                  width: 40px;
                  height: 40px;
                  border-radius: 50%;
                  background: rgba(255,255,255,0.3);
                  color: white;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-weight: bold;
                  font-size: 1.2rem;
                ">${getPlayerIcon(lastPlayer)}</div>
                <div style="flex:1; color: white;">
                  <div style="font-weight: 600; font-size: 1rem;">‚Ü©Ô∏è Continue as ${escapeQuotes(lastPlayer)}</div>
                  <div style="font-size: 0.85rem; opacity: 0.9;">Your previous session</div>
                </div>
              </div>
            `;
          }
          
          if (players.length > 0) {
            html += '<div style="margin-bottom: 20px;">';
            players.forEach((player, index) => {
              html += `
                <div class="player-option" style="
                  padding: 15px;
                  margin-bottom: 10px;
                  border: 2px solid #e0e0e0;
                  border-radius: 10px;
                  cursor: pointer;
                  transition: all 0.2s ease;
                  display: flex;
                  align-items: center;
                  gap: 15px;
                  color: ${isDark ? '#ffffff' : '#1f2937'};
                  background: ${isDark ? 'rgba(255,255,255,0.05)' : '#ffffff'};
                " onclick="selectPlayerOption('${escapeQuotes(player.name)}')">
                  <div style="
                    width: 50px;
                    height: 50px;
                    border-radius: 50%;
                    background: white;
                    border: 3px solid transparent;
                    background-image: linear-gradient(white, white), var(--story-gradient);
                    background-origin: border-box;
                    background-clip: content-box, border-box;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 1.4rem;
                  ">${getPlayerIcon(player.name)}</div>
                  <div>
                    <div style="font-weight: 600; font-size: 1.05rem; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">${player.name}</div>
                    <div style="${isDark ? 'color: #e5e7eb;' : 'color:#6b7280;'} font-size: 0.9rem;">${player.count} photos</div>
                  </div>
                </div>
              `;
            });
            html += '</div>';
          }
          
          html += `
            <div style="
              padding: 15px;
              border: 2px dashed var(--primary);
              border-radius: 10px;
              cursor: pointer;
              transition: all 0.2s ease;
              text-align: center;
              font-weight: bold;
              color: var(--primary);
            " onclick="selectNewPlayer()">
              <span style="font-size: 1.5rem;">+</span> Add New Player
            </div>
            <button onclick="closePlayerModal()" style="
              margin-top: 20px;
              width: 100%;
              padding: 12px;
              border: none;
              background: #ccc;
              border-radius: 10px;
              cursor: pointer;
              font-weight: bold;
            ">Cancel</button>
          `;
          
          content.innerHTML = html;
          modal.appendChild(content);
          document.body.appendChild(modal);
          
          // Store modal reference globally for inline onclick handlers
          window.playerSelectionModal = modal;
          window.playerSelectionResolve = resolve;
          
          // Close modal when clicking outside
          modal.onclick = (e) => {
            if (e.target === modal) {
              closePlayerModal();
            }
          };
          
          // Add hover effects
          const playerOptions = content.querySelectorAll('.player-option');
          playerOptions.forEach(option => {
            option.onmouseover = () => {
              option.style.borderColor = 'var(--primary)';
              option.style.transform = 'scale(1.02)';
            };
            option.onmouseout = () => {
              option.style.borderColor = '#e0e0e0';
              option.style.transform = 'scale(1)';
            };
          });
          
        } catch (err) {
          
          // Fallback to simple prompt
          const playerName = prompt("Enter player name:");
          if (playerName && playerName.trim()) {
            resolve(playerName.trim());
          } else {
            resolve(null);
          }
        }
      });
    }
    
    // Helper functions for player selection modal
    async function selectPlayerOption(playerName) {
      // Check authentication state
      if (authManager.hasLocalAuth(eventCode, playerName)) {
        // Player has local authentication - show continue/re-enter options
        showAuthenticationOptions(playerName);
      } else {
        // Player needs authentication - show question
        await showAuthenticationQuestion(playerName);
      }
    }

    // Show authentication options for players with local auth
    function showAuthenticationOptions(playerName) {
      const modal = window.playerSelectionModal;
      const content = modal.querySelector('div');
      const isDark = document.body.classList.contains('dark-mode');
      
      content.innerHTML = `
        <h2 style="margin-top: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'} background: var(--story-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.5rem; margin-bottom: 20px;">Welcome Back!</h2>
        
        <div style="text-align: center; margin-bottom: 30px;">
          <div style="
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: white;
            border: 4px solid transparent;
            background-image: linear-gradient(white, white), var(--story-gradient);
            background-origin: border-box;
            background-clip: content-box, border-box;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 2rem;
            margin: 0 auto 15px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          ">${getPlayerIcon(playerName)}</div>
          <h3 style="margin: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">${playerName}</h3>
        </div>

        <button onclick="continueAsPlayer('${escapeQuotes(playerName)}')" style="
          width: 100%;
          padding: 15px;
          margin-bottom: 15px;
          background: linear-gradient(135deg, #10b981, #34d399);
          color: white;
          border: none;
          border-radius: 12px;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        ">
          ‚úÖ Continue as ${playerName}
        </button>

        <button onclick="reenterSecret('${escapeQuotes(playerName)}')" style="
          width: 100%;
          padding: 15px;
          margin-bottom: 20px;
          background: linear-gradient(135deg, #6366f1, #8b5cf6);
          color: white;
          border: none;
          border-radius: 12px;
          font-size: 1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        ">
          üîë Re-enter Secret Answer
        </button>

        <button onclick="backToPlayerSelection()" style="
          width: 100%;
          padding: 12px;
          border: 2px solid #ccc;
          background: transparent;
          color: ${isDark ? '#fff' : '#666'};
          border-radius: 10px;
          cursor: pointer;
          font-weight: bold;
        ">‚Üê Back to Player List</button>
      `;
    }

    // Show authentication question for a player
    async function showAuthenticationQuestion(playerName) {
      const modal = window.playerSelectionModal;
      const content = modal.querySelector('div');
      const isDark = document.body.classList.contains('dark-mode');
      
      // Show loading while getting question
      content.innerHTML = `
        <div style="text-align: center; padding: 40px;">
          <div class="inline-spinner" style="margin: 0 auto 20px auto;"></div>
          <p style="${isDark ? 'color:#fff;' : 'color:#1f2937;'}">Getting your secret question...</p>
        </div>
      `;
      
      // Get the player's question
      const questionResult = await getPlayerQuestion(playerName);
      
      if (questionResult.success) {
        content.innerHTML = `
          <h2 style="margin-top: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'} background: var(--story-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.5rem; margin-bottom: 20px;">Secret Question</h2>
          
          <div style="text-align: center; margin-bottom: 30px;">
            <div style="
              width: 60px;
              height: 60px;
              border-radius: 50%;
              background: white;
              border: 3px solid transparent;
              background-image: linear-gradient(white, white), var(--story-gradient);
              background-origin: border-box;
              background-clip: content-box, border-box;
              color: #333;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: bold;
              font-size: 1.5rem;
              margin: 0 auto 15px auto;
            ">${getPlayerIcon(playerName)}</div>
            <h3 style="margin: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">${playerName}</h3>
          </div>

          <div style="
            background: ${isDark ? 'rgba(255,255,255,0.1)' : 'rgba(74, 144, 226, 0.1)'};
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary);
          ">
            <p style="margin: 0; font-size: 1.1rem; font-weight: 600; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">${questionResult.question}</p>
          </div>

          <input type="text" id="secretAnswer" placeholder="Your answer..." style="
            width: 100%;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            background: ${isDark ? '#374151' : '#ffffff'};
            color: ${isDark ? '#ffffff' : '#1f2937'};
          " />

          <button onclick="submitAuthentication('${escapeQuotes(playerName)}', this)" style="
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          ">
            üîì Verify & Continue
          </button>

          <button onclick="enterViewOnlyMode('${escapeQuotes(playerName)}')" style="
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 2px solid #fbbf24;
            background: transparent;
            color: #f59e0b;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
          ">üëÄ Just View Photos</button>

          <button onclick="backToPlayerSelection()" style="
            width: 100%;
            padding: 12px;
            border: 2px solid #ccc;
            background: transparent;
            color: ${isDark ? '#fff' : '#666'};
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
          ">‚Üê Back to Player List</button>
        `;
        
        // Focus on input and handle Enter key
        setTimeout(() => {
          const input = document.getElementById('secretAnswer');
          if (input) {
            input.focus();
            input.addEventListener('keypress', (e) => {
              if (e.key === 'Enter') {
                const submitBtn = document.querySelector('button[onclick*="submitAuthentication"]');
                if (submitBtn) {
                  submitAuthentication(playerName, submitBtn);
                }
              }
            });
          }
        }, 100);
      } else {
        // Player not found or error
        content.innerHTML = `
          <h2 style="margin-top: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'} background: var(--story-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.5rem; margin-bottom: 20px;">Player Not Found</h2>
          
          <div style="text-align: center; padding: 20px;">
            <p style="${isDark ? 'color:#fff;' : 'color:#1f2937;'}">This player hasn't been registered yet.</p>
          </div>

          <button onclick="enterViewOnlyMode('${escapeQuotes(playerName)}')" style="
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
          ">üëÄ View Photos Only</button>

          <button onclick="backToPlayerSelection()" style="
            width: 100%;
            padding: 12px;
            border: 2px solid #ccc;
            background: transparent;
            color: ${isDark ? '#fff' : '#666'};
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
          ">‚Üê Back to Player List</button>
        `;
      }
    }
    
    function selectNewPlayer() {
      closePlayerModal();
      addNewPlayer().then(name => {
        if (window.playerSelectionResolve && name) {
          window.playerSelectionResolve(name);
          window.playerSelectionResolve = null;
        }
      });
    }

    // Authentication flow helper functions
    function continueAsPlayer(playerName) {
      // Use stored authentication
      const storedAnswer = authManager.getStoredAnswer(eventCode, playerName);
      if (storedAnswer) {
        currentPlayerSecret = storedAnswer;
        isAuthenticated = true;
        isViewOnlyMode = false;
        
        selectPlayer(playerName);
        closePlayerModal();
        
        if (window.playerSelectionResolve) {
          window.playerSelectionResolve(playerName);
          window.playerSelectionResolve = null;
        }
      } else {
        // Fallback to re-enter secret
        reenterSecret(playerName);
      }
    }

    async function reenterSecret(playerName) {
      await showAuthenticationQuestion(playerName);
    }

    async function submitAuthentication(playerName, buttonElement) {
      const input = document.getElementById('secretAnswer');
      const answer = input ? input.value.trim() : '';
      
      if (!answer) {
        input.style.borderColor = '#ef4444';
        input.placeholder = 'Please enter your answer';
        return;
      }
      
      // Show loading
      const button = buttonElement;
      const originalText = button.innerHTML;
      button.innerHTML = '<div class="inline-spinner" style="margin: 0 auto;"></div>';
      button.disabled = true;
      
      try {
        const result = await verifyPlayerAuthentication(playerName, answer);
        
        if (result.authenticated) {
          // Success - close modal and continue
          selectPlayer(playerName);
          closePlayerModal();
          
          if (window.playerSelectionResolve) {
            window.playerSelectionResolve(playerName);
            window.playerSelectionResolve = null;
          }
        } else {
          // Failed authentication - show error and offer view-only
          input.style.borderColor = '#ef4444';
          input.value = '';
          input.placeholder = 'Incorrect answer - try again';
          
          // Show view-only option more prominently
          const viewOnlyBtn = document.querySelector('button[onclick*="enterViewOnlyMode"]');
          if (viewOnlyBtn) {
            viewOnlyBtn.style.background = 'linear-gradient(135deg, #ef4444, #f87171)';
            viewOnlyBtn.style.color = 'white';
            viewOnlyBtn.innerHTML = 'üëÄ Continue in View-Only Mode';
          }
        }
      } catch (error) {
        console.error('Authentication error:', error);
        input.style.borderColor = '#ef4444';
        input.placeholder = 'Network error - try again';
        
        // Show view-only option on network error
        const viewOnlyBtn = document.querySelector('button[onclick*="enterViewOnlyMode"]');
        if (viewOnlyBtn) {
          viewOnlyBtn.style.background = 'linear-gradient(135deg, #f59e0b, #fbbf24)';
          viewOnlyBtn.style.color = 'white';
          viewOnlyBtn.innerHTML = 'üëÄ Continue in View-Only Mode (Network Issue)';
        }
      } finally {
        if (button) {
          button.innerHTML = originalText;
          button.disabled = false;
        }
      }
    }

    function enterViewOnlyMode(playerName) {
      // Set view-only mode
      currentPlayerSecret = null;
      isAuthenticated = false;
      isViewOnlyMode = true;
      
      selectPlayer(playerName);
      closePlayerModal();
      
      if (window.playerSelectionResolve) {
        window.playerSelectionResolve(playerName);
        window.playerSelectionResolve = null;
      }
    }

    function backToPlayerSelection() {
      // Reload the original player selection modal
      closePlayerModal();
      setTimeout(() => {
        promptForPlayerSelection().then(name => {
          if (window.playerSelectionResolve && name) {
            window.playerSelectionResolve(name);
            window.playerSelectionResolve = null;
          }
        });
      }, 100);
    }
    
    function closePlayerModal() {
      if (window.playerSelectionModal && window.playerSelectionModal.parentNode) {
        window.playerSelectionModal.parentNode.removeChild(window.playerSelectionModal);
        window.playerSelectionModal = null;
      }
      if (window.playerSelectionResolve) {
        window.playerSelectionResolve(null);
        window.playerSelectionResolve = null;
      }
    }
    
    // Add new player functionality with authentication
    function addNewPlayer() {
      return new Promise((resolve) => {
        showPlayerRegistration(resolve);
      });
    }

    // Show player registration modal
    function showPlayerRegistration(resolve) {
      // Create modal for player registration
      const modal = document.createElement("div");
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        justify-content: center;
        align-items: center;
      `;
      
      const content = document.createElement("div");
      const isDark = document.body.classList.contains('dark-mode');
      content.style.cssText = `
        background: ${isDark ? '#1f2937' : 'linear-gradient(135deg, rgba(255,255,255,0.98), rgba(255,255,255,0.95))'};
        color: ${isDark ? '#ffffff' : '#1f2937'};
        padding: 30px;
        border-radius: 20px;
        max-width: 400px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        border: 2px solid rgba(228, 64, 95, 0.2);
      `;
      
      content.innerHTML = `
        <h2 style="margin-top: 0; ${isDark ? 'color:#fff;' : 'color:#1f2937;'} background: var(--story-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.5rem; margin-bottom: 20px;">Join the Fun!</h2>
        
        <div style="text-align: center; margin-bottom: 30px;">
          <div style="font-size: 3rem; margin-bottom: 10px;">üéâ</div>
          <p style="margin: 0; ${isDark ? 'color:#e5e7eb;' : 'color:#6b7280;'}">Create your player profile with a fun secret question</p>
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">Your Name</label>
          <input type="text" id="newPlayerName" placeholder="Enter your name..." style="
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            background: ${isDark ? '#374151' : '#ffffff'};
            color: ${isDark ? '#ffffff' : '#1f2937'};
          " />
        </div>

        <div id="questionSection" style="display: none;">
          <div style="
            background: ${isDark ? 'rgba(255,255,255,0.1)' : 'rgba(74, 144, 226, 0.1)'};
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary);
          ">
            <p style="margin: 0 0 10px 0; font-weight: 600; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">Your Secret Question:</p>
            <p id="assignedQuestion" style="margin: 0; font-size: 1.1rem; font-style: italic; ${isDark ? 'color:#e5e7eb;' : 'color:#4b5563;'}"></p>
          </div>

          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; ${isDark ? 'color:#fff;' : 'color:#1f2937;'}">Your Answer</label>
            <input type="text" id="secretAnswer" placeholder="Type your answer..." style="
              width: 100%;
              padding: 15px;
              border: 2px solid #e0e0e0;
              border-radius: 10px;
              font-size: 1rem;
              background: ${isDark ? '#374151' : '#ffffff'};
              color: ${isDark ? '#ffffff' : '#1f2937'};
            " />
            <small style="display: block; margin-top: 5px; ${isDark ? 'color:#9ca3af;' : 'color:#6b7280;'}">
              Remember this answer - you'll need it to upload photos on any device!
            </small>
          </div>
        </div>

        <button id="nextStepBtn" onclick="handleRegistrationStep()" style="
          width: 100%;
          padding: 15px;
          margin-bottom: 15px;
          background: linear-gradient(135deg, var(--primary), var(--secondary));
          color: white;
          border: none;
          border-radius: 12px;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
        ">
          Next Step ‚Üí
        </button>

        <button onclick="closeRegistrationModal()" style="
          width: 100%;
          padding: 12px;
          border: 2px solid #ccc;
          background: transparent;
          color: ${isDark ? '#fff' : '#666'};
          border-radius: 10px;
          cursor: pointer;
          font-weight: bold;
        ">Cancel</button>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // Store references globally
      window.registrationModal = modal;
      window.registrationResolve = resolve;
      window.registrationStep = 1;
      window.assignedQuestion = null;
      
      // Focus on name input
      setTimeout(() => {
        const nameInput = document.getElementById('newPlayerName');
        if (nameInput) {
          nameInput.focus();
          nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              handleRegistrationStep();
            }
          });
        }
      }, 100);
      
      // Close modal when clicking outside
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeRegistrationModal();
        }
      };
    }

    // Handle registration steps
    async function handleRegistrationStep() {
      if (window.registrationStep === 1) {
        // Step 1: Validate name and show question
        const nameInput = document.getElementById('newPlayerName');
        const playerName = nameInput.value.trim();
        
        if (!playerName) {
          nameInput.style.borderColor = '#ef4444';
          nameInput.placeholder = 'Please enter your name';
          return;
        }
        
        if (playerName.length < 2) {
          nameInput.style.borderColor = '#ef4444';
          nameInput.placeholder = 'Name must be at least 2 characters';
          nameInput.value = '';
          return;
        }
        
        // Check if name already exists
        try {
          const res = await fetch(`${workerURL}players?event=${eventCode}`);
          const players = await res.json();
          const existingPlayer = players.find(p => p.name.toLowerCase() === playerName.toLowerCase());
          
          if (existingPlayer) {
            nameInput.style.borderColor = '#ef4444';
            nameInput.placeholder = 'Name already taken - try another';
            nameInput.value = '';
            return;
          }
        } catch (error) {
          console.warn('Could not check existing players:', error);
        }
        
        // Generate random question
        const questions = [
          "What is your go-to snack?",
          "Favourite song right now?",
          "Favourite colour?",
          "What time of day do you like most?",
          "Your comfort food?",
          "Your favourite drink?",
          "Your favourite cartoon growing up?",
          "Your happy place?",
          "What is your lucky number?",
          "Coffee or tea?",
          "Your favourite weekend activity?",
          "What animal do you like most?",
          "Your favourite season?",
          "Your favourite movie or series?",
          "Cats, dogs, or both?",
          "Sweet or savoury?",
          "Your favourite treat as a child?",
          "Your favourite pizza topping?",
          "A word that describes you today?"
        ];
        
        window.assignedQuestion = questions[Math.floor(Math.random() * questions.length)];
        
        // Show question section
        document.getElementById('assignedQuestion').textContent = window.assignedQuestion;
        document.getElementById('questionSection').style.display = 'block';
        document.getElementById('nextStepBtn').innerHTML = 'üéâ Create Player';
        
        // Disable name input
        nameInput.disabled = true;
        nameInput.style.opacity = '0.7';
        
        // Focus on answer input
        setTimeout(() => {
          const answerInput = document.getElementById('secretAnswer');
          if (answerInput) {
            answerInput.focus();
            answerInput.addEventListener('keypress', (e) => {
              if (e.key === 'Enter') {
                handleRegistrationStep();
              }
            });
          }
        }, 100);
        
        window.registrationStep = 2;
        
      } else if (window.registrationStep === 2) {
        // Step 2: Register player
        const nameInput = document.getElementById('newPlayerName');
        const answerInput = document.getElementById('secretAnswer');
        const playerName = nameInput.value.trim();
        const answer = answerInput.value.trim();
        
        if (!answer) {
          answerInput.style.borderColor = '#ef4444';
          answerInput.placeholder = 'Please enter your answer';
          return;
        }
        
        if (answer.length < 1 || answer.length > 100) {
          answerInput.style.borderColor = '#ef4444';
          answerInput.placeholder = 'Answer must be 1-100 characters';
          answerInput.value = '';
          return;
        }
        
        // Show loading
        const button = document.getElementById('nextStepBtn');
        const originalText = button.innerHTML;
        button.innerHTML = '<div class="inline-spinner" style="margin: 0 auto;"></div>';
        button.disabled = true;
        
        try {
          const result = await registerNewPlayer(playerName, answer);
          
          if (result.success) {
            // Success - set player and close modal
            currentPlayer = playerName;
            try { 
              localStorage.setItem(`eventbingo:lastPlayer:${eventCode}`, currentPlayer); 
            } catch(_) {}
            
            selectPlayer(playerName);
            closeRegistrationModal();
            
            if (window.registrationResolve) {
              window.registrationResolve(playerName);
              window.registrationResolve = null;
            }
          } else {
            // Registration failed
            answerInput.style.borderColor = '#ef4444';
            answerInput.placeholder = result.message || 'Registration failed';
            answerInput.value = '';
          }
        } catch (error) {
          console.error('Registration error:', error);
          answerInput.style.borderColor = '#ef4444';
          answerInput.placeholder = 'Network error - try again';
        } finally {
          button.innerHTML = originalText;
          button.disabled = false;
        }
      }
    }

    function closeRegistrationModal() {
      if (window.registrationModal && window.registrationModal.parentNode) {
        window.registrationModal.parentNode.removeChild(window.registrationModal);
        window.registrationModal = null;
      }
      if (window.registrationResolve) {
        window.registrationResolve(null);
        window.registrationResolve = null;
      }
    }

    // Test worker connection
    async function testWorkerConnection() {
      try {
        
        const res = await fetch(workerURL);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const text = await res.text();
        
        return true;
      } catch (err) {
        
        
        // Show user-friendly error message with deployment instructions
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: #ff6b6b;
          color: white;
          padding: 20px 25px;
          border-radius: 10px;
          box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          z-index: 10000;
          font-weight: 600;
          text-align: center;
          max-width: 90%;
        `;
        errorDiv.innerHTML = `
          ‚ö†Ô∏è EventBingo Worker Not Deployed<br>
          <small style="font-size: 0.9em; margin-top: 10px; display: block;">
            The worker needs to be deployed to Cloudflare Workers.<br>
            Check the EventBingo/worker.js file and deploy it to your Cloudflare account.
          </small>
        `;
        document.body.appendChild(errorDiv);
        
        // Auto-hide after 8 seconds (longer for instructions)
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
        }, 8000);
        
        return false;
      }
    }

    // Initialize app
    createGrid();
    

    testWorkerConnection().then(connected => {
      if (connected) {
        loadPlayers();
        updateLeaderboard();
      } else {
        
      }
    });

    // Legacy initialization - kept for compatibility but integrated into main init
    function legacyInitialization() {
      // Wire up always-visible Add Player button on the right
      const addPlayerTopBtn = document.getElementById('addPlayerTopBtn');
      if (addPlayerTopBtn) {
        addPlayerTopBtn.addEventListener('click', async () => {
          const selected = await promptForPlayerSelection();
          if (selected) {
            currentPlayer = selected;
            createGrid();
            loadPhotos(currentPlayer);
            loadPlayers();
            hasPromptedForPlayer = true;
          }
        });
      }

      // Prompt immediately on page load if no player is selected yet
      setTimeout(async () => {
        if (!currentPlayer && !hasPromptedForPlayer) {
          hasPromptedForPlayer = true;
          const name = await promptForPlayerSelection();
          if (name) {
            currentPlayer = name;
            createGrid();
            loadPhotos(currentPlayer);
            loadPlayers();
          }
        }
      }, 300);
    }

    async function loadEventInfo() {
      try {
        const res = await fetch(`${workerURL}event-info?event=${eventCode}`);
        if (res.ok) {
          currentEvent = await res.json();
          
          // Ensure backward compatibility - handle both old and new event formats
          if (currentEvent) {
            // Load custom squares from event data with proper validation
            if (currentEvent.squares && Array.isArray(currentEvent.squares)) {
              if (currentEvent.squares.length === 25) {
                // Validate that all squares are non-empty strings
                const validSquares = currentEvent.squares.filter(square => 
                  typeof square === 'string' && square.trim().length > 0
                );
                
                if (validSquares.length === 25) {
                  squares = currentEvent.squares.map(square => square.trim());
                  console.log('Loaded custom squares for event:', eventCode);
                } else {
                  console.warn(`Event has ${validSquares.length}/25 valid squares, falling back to default squares`);
                  squares = defaultSquaresList;
                }
              } else {
                console.warn(`Event has ${currentEvent.squares.length} squares (expected 25), falling back to default squares`);
                squares = defaultSquaresList;
              }
            } else {
              // No custom squares or invalid format, use default (backward compatibility)
              console.log('No custom squares found for event, using default squares (backward compatibility)');
              squares = defaultSquaresList;
            }
            
            // Ensure event has required fields for backward compatibility
            if (!currentEvent.title) {
              currentEvent.title = "EventBingo";
            }
            if (!currentEvent.description) {
              currentEvent.description = "A fun photo challenge game!";
            }
            if (!currentEvent.code) {
              currentEvent.code = eventCode || "default";
            }
          } else {
            throw new Error('Invalid event data received');
          }
          
          createGrid();
          updateEventDisplay();
        } else {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
      } catch (err) {
        console.error('Failed to load event info:', err);
        
        // Fallback for backward compatibility - create default event
        currentEvent = {
          title: "EventBingo",
          description: "A fun photo challenge game!",
          code: eventCode || "default"
        };
        squares = defaultSquaresList; // Always fallback to default squares
        
        console.log('Using fallback event configuration with default squares');
        
        createGrid();
        updateEventDisplay();
      }
    }

    function updateEventDisplay() {
      if (currentEvent) {
        // Update page title
        document.title = `${currentEvent.title} - EventBingo`;
        
        // Update event banner
        const banner = document.getElementById('eventBanner');
        const bannerTitle = document.getElementById('eventBannerTitle');
        const bannerCode = document.getElementById('eventBannerCode');
        if (banner && bannerTitle && bannerCode) {
          bannerTitle.textContent = currentEvent.title;
          bannerCode.textContent = `Code: ${currentEvent.code}`;
          banner.style.display = 'flex';
        }
      }
    }

    // Initialize app with page loading
    document.addEventListener('DOMContentLoaded', async function() {
      // If no event parameter, guide users to info page first
      const urlParams = new URLSearchParams(window.location.search);
      const hasEvent = urlParams.has('event');
      if (!hasEvent) {
        // Preserve any potential referral info if present
        window.location.replace('info.html');
        return;
      }

      // Get event code from URL parameters
      eventCode = urlParams.get('event') || 'default';
      
      showPageLoading("Loading EventBingo...");
      
      try {
        // Initialize the app
        await initializeApp();
        
        // Setup legacy functionality
        legacyInitialization();
      } catch (error) {
        console.error('Failed to initialize app:', error);
        
        // Fallback initialization if main init fails
        console.log('Attempting fallback initialization...');
        try {
          await loadEventInfo();
          legacyInitialization();
        } catch (fallbackError) {
          console.error('Fallback initialization also failed:', fallbackError);
        }
      } finally {
        hidePageLoading();
      }
    });

    async function loadEventData() {
      // Load event information and squares
      await loadEventInfo();
    }

    // Helper function to validate squares data
    function validateSquares(squaresData) {
      if (!Array.isArray(squaresData)) {
        return { valid: false, reason: 'Not an array' };
      }
      
      if (squaresData.length !== 25) {
        return { valid: false, reason: `Expected 25 squares, got ${squaresData.length}` };
      }
      
      const validSquares = squaresData.filter(square => 
        typeof square === 'string' && square.trim().length > 0
      );
      
      if (validSquares.length !== 25) {
        return { valid: false, reason: `${validSquares.length}/25 squares are valid non-empty strings` };
      }
      
      return { valid: true, reason: 'All squares are valid' };
    }

    async function loadSquares() {
      // Squares are loaded as part of loadEventInfo()
      // This function exists for compatibility with the initialization flow
      if (!squares || squares.length === 0) {
        console.log('No squares loaded, using default squares');
        squares = defaultSquaresList;
      }
      
      // Final validation to ensure we always have valid squares
      const validation = validateSquares(squares);
      if (!validation.valid) {
        console.warn('Squares validation failed:', validation.reason, 'Using default squares');
        squares = defaultSquaresList;
      }
    }

    async function initializeApp() {
      // Check for player in URL params
      const urlParams = new URLSearchParams(window.location.search);
      const urlPlayer = urlParams.get('player');
      if (urlPlayer) {
        currentPlayer = urlPlayer;
        try {
          localStorage.setItem('eventbingo:currentPlayer', urlPlayer);
          localStorage.setItem(`eventbingo:lastPlayer:${eventCode}`, urlPlayer);
        } catch(_) {}
      }
      
      // Load event data and squares
      if (eventCode && eventCode !== 'default') {
        showPageLoading("Loading event data...");
        await loadEventData();
      } else {
        // For default events, just load default squares
        showPageLoading("Loading challenges...");
        await loadSquares();
      }
      
      // Create grid
      showPageLoading("Setting up game board...");
      createGrid();
      
      // Load players
      showPageLoading("Loading players...");
      await loadPlayers();
      
      // Load photos for current player
      if (currentPlayer) {
        showPageLoading("Loading your photos...");
        await loadPhotos(currentPlayer);
      }
      
      // Setup event handlers
      setupEventHandlers();
    }

    function setupEventHandlers() {
      // Add player button
      const addPlayerBtn = document.getElementById('addPlayerTopBtn');
      if (addPlayerBtn) {
        addPlayerBtn.addEventListener('click', addNewPlayer);
      }
    }
</script>