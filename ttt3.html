<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Triple Tic Tac Toe â€” Hex (fixed)</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --felt-green:#0a4821;
    --dark-wood:#2a1a1f;
    --gold:#ffd700;
    --light-gold:#fff8e1;
    --player1-color:#ff6b6b;
    --player2-color:#4ecdc4;
    --player3-color:#ffe66d;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:'Lato',sans-serif;
    background-color:var(--dark-wood);
    display:flex;justify-content:center;align-items:center;min-height:100vh;padding:1.5rem;
  }
  .casino-table{
    background:var(--felt-green);
    border:10px solid #4a2c2a;
    box-shadow:0 0 0 5px var(--gold), inset 0 0 25px rgba(0,0,0,.5);
    border-radius:15px;padding:1.5rem;width:100%;max-width:760px;position:relative;
  }
  h1{font-family:'Cinzel',serif;color:var(--gold);font-size:1.9rem;margin-bottom:.6rem}
  .players{display:flex;gap:.5rem;justify-content:space-between;margin-bottom:.6rem}
  .player{background:linear-gradient(145deg,#3e1e24,#2a1a1f);padding:.6rem;border-radius:10px;width:32%;border:3px solid #111;color:var(--light-gold)}
  .player.active{box-shadow:0 0 12px var(--gold)}
  .mark{font-weight:700}
  #game-status{color:var(--light-gold);margin:8px 0 12px;font-weight:700}
  .board-wrap{display:flex;justify-content:center;align-items:center}
  svg#board{max-width:100%;height:auto;display:block}
  .hex{cursor:pointer;transition:transform .12s}
  .hex:hover{transform:scale(1.05)}
  .hex.win polygon{stroke:var(--gold);stroke-width:4}
  .piece line,.piece circle,.piece polygon{pointer-events:none}
  .move-history{display:flex;gap:6px;justify-content:center;margin-top:8px}
  .history-dot{width:8px;height:8px;border-radius:50%}
  .history-dot.x{background:var(--player1-color)}
  .history-dot.o{background:var(--player2-color)}
  .history-dot.delta{background:var(--player3-color)}
  .controls{display:flex;justify-content:center;margin-top:12px}
  button{padding:.6rem 1rem;border-radius:8px;border:2px solid #111;background:var(--gold);cursor:pointer}
  .win-message{position:absolute;top:18%;left:50%;transform:translateX(-50%);background:#2a1a1f;color:var(--light-gold);padding:1rem;border-radius:12px;border:3px solid var(--gold);display:none}
  .win-message.show{display:block}
  @media (max-width:600px){ .casino-table{padding:1rem;max-width:95vw} h1{font-size:1.6rem} }
</style>
</head>
<body>
  <div class="casino-table" role="application" aria-label="Triple Tic Tac Toe">
    <h1>Triple Tic Tac Toe â€” Hex (n=4)</h1>

    <div class="players" aria-hidden="false">
      <div id="player-1" class="player active"><div><strong id="player-1-name">Player X</strong></div><div class="mark">X</div><div>Wins: <span id="player-1-wins">0</span></div></div>
      <div id="player-2" class="player"><div><strong id="player-2-name">Player O</strong></div><div class="mark">O</div><div>Wins: <span id="player-2-wins">0</span></div></div>
      <div id="player-3" class="player"><div><strong id="player-3-name">Player Î”</strong></div><div class="mark">Î”</div><div>Wins: <span id="player-3-wins">0</span></div></div>
    </div>

    <div id="game-status" aria-live="polite">Player X's turn</div>

    <div class="board-wrap">
      <svg id="board" role="grid" aria-label="Hex board"></svg>
    </div>

    <div class="move-history" id="move-history" aria-hidden="false"></div>

    <div class="controls">
      <button id="btn-reset">ðŸ”„ New Game</button>
    </div>

    <div class="win-message" id="win-message" role="dialog" aria-modal="true">
      <h3 id="winner-text">Winner</h3>
      <div style="text-align:center;margin-top:.6rem"><button id="btn-continue">Continue</button></div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // CONFIG
  const N = 4;
  const KEEP_EMPTY = 6;
  const WIN_LENGTH = 4;
  const HEX_SIZE = 36;

  // PLAYERS
  const players = [
    { id: 0, mark: 'X', color: getCss('--player1-color') },
    { id: 1, mark: 'O', color: getCss('--player2-color') },
    { id: 2, mark: 'Î”', color: getCss('--player3-color') }
  ];

  // DOM
  const svg = document.getElementById('board');
  const statusEl = document.getElementById('game-status');
  const moveHistoryEl = document.getElementById('move-history');
  const btnReset = document.getElementById('btn-reset');
  const btnContinue = document.getElementById('btn-continue');
  const winMsg = document.getElementById('win-message');
  const winnerText = document.getElementById('winner-text');
  const playerCards = [document.getElementById('player-1'), document.getElementById('player-2'), document.getElementById('player-3')];
  const playerNameEls = [document.getElementById('player-1-name'), document.getElementById('player-2-name'), document.getElementById('player-3-name')];
  const playerWinsEls = [document.getElementById('player-1-wins'), document.getElementById('player-2-wins'), document.getElementById('player-3-wins')];

  // AXIAL helper
  const radius = N - 1;
  const dirs = [[1,0],[0,1],[-1,1]];
  function axialToPixel(q,r){ return [ HEX_SIZE * 1.5 * q, HEX_SIZE * (Math.sqrt(3) * (r + q/2)) ]; }
  function key(q,r){ return `${q},${r}`; }

  // STATE
  let cells = new Map(); // key -> { q,r, g, poly, pieceGroup, owner }
  let currentPlayer = 0;
  let gameActive = true;
  let wins = [0,0,0];
  let moveHistory = []; // {q,r,player}
  let winningKeys = [];

  // BUILD coords + svg sizing
  const axial = [];
  for(let q=-radius; q<=radius; q++){
    const r1 = Math.max(-radius, -q-radius);
    const r2 = Math.min(radius, -q+radius);
    for(let r=r1; r<=r2; r++) axial.push([q,r]);
  }
  const centers = axial.map(([q,r]) => axialToPixel(q,r));
  const minX = Math.min(...centers.map(c=>c[0])) - HEX_SIZE - 4;
  const maxX = Math.max(...centers.map(c=>c[0])) + HEX_SIZE + 4;
  const minY = Math.min(...centers.map(c=>c[1])) - HEX_SIZE - 4;
  const maxY = Math.max(...centers.map(c=>c[1])) + HEX_SIZE + 4;
  svg.setAttribute('viewBox', `${minX} ${minY} ${maxX-minX} ${maxY-minY}`);
  svg.style.width = Math.min(760, maxX-minX) + 'px';
  svg.style.maxWidth = '100%';
  svg.style.height = 'auto';

  // defs
  const defs = create('defs');
  const grad = create('radialGradient', { id:'feltCell', cx:'50%', cy:'40%', r:'70%' });
  grad.appendChild(create('stop', { offset:'0%', 'stop-color':'#0f5a2c' }));
  grad.appendChild(create('stop', { offset:'100%', 'stop-color':'#0a4821' }));
  defs.appendChild(grad);
  svg.appendChild(defs);

  // draw hexes: each group translated to center; shapes centered at 0,0
  for(const [q,r] of axial){
    const [cx,cy] = axialToPixel(q,r);
    const g = create('g', { class:'hex', 'data-q':String(q), 'data-r':String(r), transform:`translate(${cx},${cy})` });
    const poly = create('polygon', { points: hexPoints(0,0,HEX_SIZE), fill:'url(#feltCell)' });
    const piece = create('g', { class:'piece' });
    g.appendChild(poly);
    g.appendChild(piece);
    svg.appendChild(g);
    // robust click handler reads dataset (no closure issues)
    g.addEventListener('click', (evt) => {
      const qq = Number(g.getAttribute('data-q'));
      const rr = Number(g.getAttribute('data-r'));
      onCellClick(qq, rr);
    });
    cells.set(key(q,r), { q, r, g, poly, pieceGroup: piece, owner: null });
  }

  // init UI
  updateStatus();
  updateTurnIndicator();
  updateMoveHistory();

  // events
  btnReset.addEventListener('click', newGame);
  btnContinue.addEventListener('click', () => { winMsg.classList.remove('show'); newRound(); });

  // HANDLERS
  function onCellClick(q,r){
    if(!gameActive) return;
    const c = cells.get(key(q,r));
    if(!c || c.owner !== null) return;
    placePiece(c, currentPlayer);
    // check win first (so winner = currentPlayer)
    const winKeys = checkWinFrom(q,r,currentPlayer);
    if(winKeys){
      highlightWin(winKeys);
      gameActive = false;
      wins[currentPlayer]++; playerWinsEls[currentPlayer].textContent = wins[currentPlayer];
      winnerText.textContent = `${playerNameEls[currentPlayer].textContent} wins!`;
      updateStatus();
      winMsg.classList.add('show');
      return;
    }
    // enforce empty-rule AFTER we check the win on the just-played board
    enforceEmptyRule();
    currentPlayer = (currentPlayer + 1) % players.length;
    updateStatus();
    updateTurnIndicator();
  }

  function placePiece(cell, playerId){
    cell.owner = playerId;
    drawPiece(cell.pieceGroup, playerId);
    moveHistory.push({ q: cell.q, r: cell.r, player: playerId });
    updateMoveHistory();
  }

  function removePieceAt(q,r){
    const c = cells.get(key(q,r));
    if(!c || c.owner===null) return;
    c.owner = null;
    c.g.classList.remove('win');
    c.pieceGroup.replaceChildren();
  }

  function enforceEmptyRule(){
    let empties = countEmpty();
    while(empties < KEEP_EMPTY && moveHistory.length){
      const oldest = moveHistory.shift();
      removePieceAt(oldest.q, oldest.r);
      empties = countEmpty();
    }
    updateMoveHistory();
  }

  function countEmpty(){ let n=0; for(const v of cells.values()) if(v.owner===null) n++; return n; }

  function drawPiece(group, playerId){
    group.replaceChildren();
    const color = players[playerId].color;
    if(playerId===0){
      const l1 = create('line', { x1:-HEX_SIZE*0.45, y1:-HEX_SIZE*0.45, x2:HEX_SIZE*0.45, y2:HEX_SIZE*0.45, stroke:color, 'stroke-width':6, 'stroke-linecap':'round' });
      const l2 = create('line', { x1:HEX_SIZE*0.45, y1:-HEX_SIZE*0.45, x2:-HEX_SIZE*0.45, y2:HEX_SIZE*0.45, stroke:color, 'stroke-width':6, 'stroke-linecap':'round' });
      group.appendChild(l1); group.appendChild(l2);
    } else if(playerId===1){
      const c = create('circle', { cx:0, cy:0, r:HEX_SIZE*0.42, fill:'none', stroke:color, 'stroke-width':6 });
      group.appendChild(c);
    } else {
      const tri = create('polygon', { points: trianglePoints(HEX_SIZE*0.55), fill:color });
      group.appendChild(tri);
    }
    group.setAttribute('transform','translate(0,0)');
  }

  // WIN CHECK
  function checkWinFrom(q,r,playerId){
    for(const [dq,dr] of dirs){
      const run = [ key(q,r) ];
      let nq=q+dq, nr=r+dr;
      while(ownedBy(nq,nr,playerId)){ run.push(key(nq,nr)); nq+=dq; nr+=dr; }
      nq=q-dq; nr=r-dr;
      while(ownedBy(nq,nr,playerId)){ run.unshift(key(nq,nr)); nq-=dq; nr-=dr; }

      if(run.length >= WIN_LENGTH){
        // return a contiguous window (length WIN_LENGTH) that includes the played cell
        const idx = run.indexOf(key(q,r));
        let start = Math.max(0, idx - (WIN_LENGTH - 1));
        let end = start + WIN_LENGTH;
        if(end > run.length){ end = run.length; start = end - WIN_LENGTH; }
        return run.slice(start, end);
      }
    }
    return null;
  }

  function ownedBy(q,r,playerId){
    const c = cells.get(key(q,r)); return c && c.owner===playerId;
  }

  function highlightWin(keys){
    winningKeys = keys;
    for(const k of keys){
      const c = cells.get(k);
      if(c) c.g.classList.add('win');
    }
  }

  function clearWinHighlight(){
    for(const k of (winningKeys || [])){
      const c = cells.get(k); if(c) c.g.classList.remove('win');
    }
    winningKeys = [];
  }

  // ROUNDS & GAMES
  function newRound(){
    moveHistory = [];
    clearWinHighlight();
    for(const v of cells.values()){ v.owner = null; v.pieceGroup.replaceChildren(); v.g.classList.remove('win'); }
    gameActive = true;
    // start next round with next player for fairness
    currentPlayer = (currentPlayer + 1) % players.length;
    updateMoveHistory();
    updateStatus();
    updateTurnIndicator();
  }

  function newGame(){
    wins = [0,0,0];
    playerWinsEls.forEach((el,i)=>el.textContent = wins[i]);
    currentPlayer = 0;
    winMsg.classList.remove('show');
    newRound();
  }

  // UI updates
  function updateStatus(){
    if(!gameActive && winningKeys && winningKeys.length){
      statusEl.textContent = `${playerNameEls[(currentPlayer+players.length-1)%players.length].textContent} wins!`; // last mover
    } else {
      statusEl.textContent = `${playerNameEls[currentPlayer].textContent}'s turn`;
    }
  }

  function updateTurnIndicator(){
    playerCards.forEach((card,i)=>card.classList.toggle('active', i===currentPlayer));
  }

  function updateMoveHistory(){
    moveHistoryEl.innerHTML = '';
    for(const mv of moveHistory){
      const dot = document.createElement('div');
      dot.className = 'history-dot ' + (mv.player===0?'x':mv.player===1?'o':'delta');
      moveHistoryEl.appendChild(dot);
    }
  }

  function editName(idx){
    const label = playerNameEls[idx];
    const parent = label.parentElement;
    const input = document.createElement('input');
    input.type='text'; input.value = label.textContent; input.className='player-name-input';
    parent.replaceChild(input,label); input.focus();
    const save = ()=>{ const val = input.value.trim() || ['Player X','Player O','Player Î”'][idx];
      label.textContent = val; parent.replaceChild(label,input); updateStatus(); };
    input.addEventListener('blur', save);
    input.addEventListener('keydown', e=>{ if(e.key==='Enter'){ input.blur(); }});
  }

  // SVG helpers
  function create(tag, attrs={}){
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }
  function hexPoints(cx,cy,size){
    const pts=[];
    for(let k=0;k<6;k++){
      const ang = Math.PI/180*(60*k);
      const x = cx + size * Math.cos(ang);
      const y = cy + size * Math.sin(ang);
      pts.push(`${x},${y}`);
    }
    return pts.join(' ');
  }
  function trianglePoints(s){
    const h = s * Math.sqrt(3)/2;
    return `0,${-h} ${-s/2},${h} ${s/2},${h}`;
  }
  function getCss(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

  // expose edit icons (small convenience)
  document.querySelectorAll('.player strong').forEach((el, idx) => {
    el.tabIndex = 0;
    el.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') editName(idx); });
    el.addEventListener('click', ()=> editName(idx));
  });

  // start clean
  newGame();
});
</script>
</body>
</html>