<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Triple Tic Tac Toe — Casino Style (n=4)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Lato:wght@400;700&display=swap" rel="stylesheet">

<style>
/* ===== Casino Theme ===== */
:root{
  --felt-green: #0a4821;
  --dark-wood: #2a1a1f;
  --gold: #ffd700;
  --light-gold: #fff8e1;
  --ivory: #faf8f0;
  --player1-color: #ff6b6b;
  --player2-color: #4ecdc4;
  --player3-color: var(--gold);
}
/* Reset / base */
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:'Lato',sans-serif;
  background-color:var(--dark-wood);
  background-image:radial-gradient(circle,#4d322e 0%,var(--dark-wood) 70%);
  display:flex;justify-content:center;align-items:center;min-height:100vh;padding:1.5rem;
  -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  touch-action:manipulation;
}

/* Casino table container */
.casino-table{
  background:var(--felt-green);
  background-image:
    radial-gradient(rgba(255,255,255,0.08) 1px, transparent 1px),
    radial-gradient(rgba(255,255,255,0.08) 1px, var(--felt-green) 1px);
  background-size:4px 4px; background-position:0 0,2px 2px;
  border:10px solid #4a2c2a;
  box-shadow:0 0 0 5px var(--gold), inset 0 0 25px rgba(0,0,0,0.5);
  border-radius:15px;padding:2rem;width:100%;position:relative;overflow:hidden;
}

/* Title */
h1{
  font-family:'Cinzel',serif;font-weight:700;color:var(--gold);
  font-size:2.2rem;text-shadow:2px 2px 5px rgba(0,0,0,0.7);margin-bottom:1.5rem;text-align:center;
}

/* Players row: left -> right */
.players{
  display:flex;flex-direction:row;justify-content:space-around;gap:1rem;margin-bottom:1.5rem;height:auto;
}
.player{
  background:linear-gradient(145deg,#3e1e24,#2a1a1f);
  padding:0.5rem 1rem;border-radius:10px;border:3px solid #1a1a1a;
  box-shadow:inset 0 2px 5px rgba(0,0,0,0.5),0 5px 15px rgba(0,0,0,0.4);
  width:auto;min-width:unset;color:var(--light-gold);text-align:center;flex-shrink:unset;
  transition: all 0.3s ease;
}
.player-header{display:flex;justify-content:center;align-items:center;gap:.5rem;margin-bottom:.5rem}
.player-header h2{font-family:'Cinzel',serif;font-weight:700; font-size: 1.2rem; color: var(--light-gold);}
.mark{font-size: 2rem; font-weight: bold; color: var(--gold); text-shadow: 1px 1px 3px rgba(0,0,0,0.5); font-family: 'Cinzel', serif;}
.player .wins{margin-top:.5rem;font-size:1.1rem;color:var(--light-gold)}
.player.active{border-color:var(--gold);transform:scale(1.05);box-shadow:inset 0 2px 5px rgba(0,0,0,0.5),0 5px 15px rgba(0,0,0,0.4), 0 0 20px var(--gold)}
/* These specific player active border colors are no longer needed as the generic .player.active handles it */
/*
.player-1.active{border-color:var(--player1-color)}
.player-2.active{border-color:var(--player2-color)}
.player-3.active{border-color:var(--player3-color)}
*/

/* Panel symbols - these styles are no longer needed as symbols are text in HTML */
/*
.symbol{
  display:inline-flex;align-items:center;justify-content:center;
  width:40px;height:40px;position:relative;
}
.symbol.x::before,.symbol.x::after{
  content:'';position:absolute;width:75%;height:6px;background:var(--player1-color);border-radius:5px;
}
.symbol.x::before{transform:rotate(45deg)}
.symbol.x::after{transform:rotate(-45deg)}
.symbol.o{border:6px solid var(--player2-color);border-radius:50%}
.symbol.delta svg{display:block}
*/

/* Status */
#game-status{
  min-height:24px;font-size:1.2rem;font-weight:700;color:var(--light-gold);
  margin-bottom:1rem;text-shadow:1px 1px 2px black;text-align:center
}

/* Game area / board */
.game-area{display:flex;gap:1rem;flex-direction:column;align-items:center;justify-content:center;}
.board-wrap{display:flex;justify-content:center;align-items:center;padding:8px}
svg#board{width:100%;height:100%;max-width:calc(100% - 16px);display:block;touch-action:manipulation;}

/* Hex styling */
.hex > polygon{
  fill:url(#cellGrad);
  stroke:var(--gold);stroke-width:2;
  filter:drop-shadow(0 2px 4px rgba(0,0,0,0.35));
  transition:transform .08s, stroke .12s;
}
.hex:hover polygon{transform:scale(1.01)}
.hex.win polygon{stroke:var(--gold);stroke-width:4;filter:drop-shadow(0 0 6px var(--gold))}

/* Move history */
.move-history{display:flex;justify-content:center;gap:6px;margin-top:10px;flex-wrap:wrap}
.history-dot{width:8px;height:8px;border-radius:50%}
.history-dot.x{background:var(--player1-color)}
.history-dot.o{background:var(--player2-color)}
.history-dot.delta{background:var(--player3-color)}

/* Controls */
.controls{margin-top:12px;display:flex;gap:8px;justify-content:center}
button{
  font-family:'Cinzel',serif;font-weight:600;padding:.6rem 1rem;border-radius:8px;border:2px solid #111;cursor:pointer;
  background:linear-gradient(145deg,var(--gold),#b8860b);color:#111
}
button:active{transform:translateY(2px)}

/* Responsive */
@media (max-width:720px){
  svg#board{width:calc(100% - 30px);}
  .players{flex-direction:column;gap:0.6rem}
  .player{width:100%}
}
</style>
</head>
<body>
  <div class="casino-table" role="application" aria-label="Triple Tic Tac Toe Casino">
    <h1>Triple Tic Tac Toe — Hex (n=4)</h1>

    <!-- Players left -> right -->
    <div class="players" id="players">
      <div class="player player-1 active" id="playerCard0">
        <div class="player-header">
          <h2 class="name" id="pname0">Player X</h2>
        </div>
        <p class="mark">X</p>
        <p class="wins">Wins: <span id="pw0">0</span></p>
      </div>

      <div class="player player-2" id="playerCard1">
        <div class="player-header">
          <h2 class="name" id="pname1">Player O</h2>
        </div>
        <p class="mark">O</p>
        <p class="wins">Wins: <span id="pw1">0</span></p>
      </div>

      <div class="player player-3" id="playerCard2">
        <div class="player-header">
          <h2 class="name" id="pname2">Player Δ</h2>
        </div>
        <p class="mark">Δ</p>
        <p class="wins">Wins: <span id="pw2">0</span></p>
      </div>
    </div>

    <div id="game-status">Player X's turn</div>

    <div class="game-area">
      <div class="board-wrap">
        <svg id="board" role="grid" aria-label="Hex board"></svg>
      </div>

      <div class="move-history" id="move-history" aria-hidden="false"></div>

      <div class="controls">
        <button id="btn-new-round">New Round</button>
        <button id="btn-new-game">New Game</button>
      </div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Config
  const N = 4;          // side length
  const SIZE = 80;      // hex radius (px)

  // CSS vars
  const cssVar = n => getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const playerColors = [cssVar('--player1-color'), cssVar('--player2-color'), cssVar('--player3-color')];
  const players = [{id:0, name:'Player X'}, {id:1, name:'Player O'}, {id:2, name:'Player Δ'}];

  // DOM
  const svg = document.getElementById('board');
  const statusEl = document.getElementById('game-status');
  const moveHistoryEl = document.getElementById('move-history');
  const playerCards = [document.getElementById('playerCard0'), document.getElementById('playerCard1'), document.getElementById('playerCard2')];
  const playerNameEls = [document.getElementById('pname0'), document.getElementById('pname1'), document.getElementById('pname2')];
  const playerWinsEls = [document.getElementById('pw0'), document.getElementById('pw1'), document.getElementById('pw2')];
  const btnNewRound = document.getElementById('btn-new-round');
  const btnNewGame = document.getElementById('btn-new-game');

  // Axial helpers (flat-top)
  const radius = N - 1;
  function axialToPixel(q, r){
    const x = SIZE * 1.5 * q;
    const y = SIZE * (Math.sqrt(3) * (r + q/2));
    return [x, y];
  }
  function key(q,r){ return `${q},${r}`; }

  // Build axial coords of hex of radius (N-1)
  const axial = [];
  for(let q=-radius; q<=radius; q++){
    const r1 = Math.max(-radius, -q - radius);
    const r2 = Math.min(radius, -q + radius);
    for(let r=r1; r<=r2; r++) axial.push([q,r]);
  }

  // compute viewBox to fit board
  const centers = axial.map(([q,r]) => axialToPixel(q,r));
  const minX = Math.min(...centers.map(c=>c[0])) - SIZE;
  const maxX = Math.max(...centers.map(c=>c[0])) + SIZE;
  const minY = Math.min(...centers.map(c=>c[1])) - SIZE;
  const maxY = Math.max(...centers.map(c=>c[1])) + SIZE;
  svg.setAttribute('viewBox', `${minX} ${minY} ${maxX-minX} ${maxY-minY}`);
  //svg.setAttribute('width', Math.min(640, maxX-minX)); // Remove this line to allow full responsiveness
  svg.style.aspectRatio = `${(maxX-minX)/(maxY-minY)}`;

  // SVG helpers
  const NS = 'http://www.w3.org/2000/svg';
  const create = (tag, attrs={}) => {
    const el = document.createElementNS(NS, tag);
    for(const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  };
  function hexPoints(cx, cy, s){
    const pts = [];
    for(let k=0;k<6;k++){
      const ang = Math.PI/180*(60*k);
      pts.push(`${cx + s*Math.cos(ang)},${cy + s*Math.sin(ang)}`);
    }
    return pts.join(' ');
  }
  function triPoints(R){
    // Equilateral triangle pointing upwards, centered at (0,0) with circumradius R
    const p1_x = 0;
    const p1_y = -R;
    const p2_x = -R * Math.sqrt(3) / 2;
    const p2_y = R / 2;
    const p3_x = R * Math.sqrt(3) / 2;
    const p3_y = R / 2;
    return `${p1_x},${p1_y} ${p2_x},${p2_y} ${p3_x},${p3_y}`;
  }

  // defs gradient for cells
  const defs = create('defs');
  const grad = create('radialGradient', { id:'cellGrad', cx:'50%', cy:'40%', r:'70%' });
  grad.appendChild(create('stop', { offset:'0%', 'stop-color':'#0f5a2c' }));
  grad.appendChild(create('stop', { offset:'100%', 'stop-color':'#0a4821' }));
  defs.appendChild(grad);
  svg.appendChild(defs);

  // State
  const cells = new Map(); // key -> {q,r,g,poly,pieceGroup,owner}
  let currentPlayer = 0;
  let moveHistory = [];
  let wins = [0,0,0];
  let gameActive = true; // Flag to control game activity

  // Draw board
  for(const [q,r] of axial){
    const [cx,cy] = axialToPixel(q,r);
    const g = create('g', { class:'hex', 'data-q':String(q), 'data-r':String(r) });
    const poly = create('polygon', { points: hexPoints(cx,cy,SIZE), fill:'url(#cellGrad)' });
    const piece = create('g', { class:'piece', transform:`translate(${cx},${cy})` });
    g.appendChild(poly);
    g.appendChild(piece);
    svg.appendChild(g);

    g.addEventListener('click', () => onCellClick(q,r));

    cells.set(key(q,r), { q, r, g, poly, pieceGroup:piece, owner:null });
  }

  // UI helpers
  function setActivePlayer(idx){
    playerCards.forEach((card,i)=>card.classList.toggle('active', i===idx));
    statusEl.textContent = `${playerNameEls[idx].textContent}'s turn`;
  }
  function updateMoveHistory(){
    moveHistoryEl.innerHTML = '';
    for(const mv of moveHistory){
      const dot = document.createElement('div');
      dot.className = 'history-dot ' + (mv.player===0?'x':mv.player===1?'o':'delta');
      moveHistoryEl.appendChild(dot);
    }
  }

  // Draw a piece into a pieceGroup at its local origin
  function drawPiece(group, playerId){
    group.replaceChildren();
    const color = playerColors[playerId];
    if(playerId === 0){
      const l1 = create('line', { x1:-SIZE*0.45, y1:-SIZE*0.45, x2:SIZE*0.45, y2:SIZE*0.45, stroke:color, 'stroke-width':6, 'stroke-linecap':'round' });
      const l2 = create('line', { x1:SIZE*0.45, y1:-SIZE*0.45, x2:-SIZE*0.45, y2:SIZE*0.45, stroke:color, 'stroke-width':6, 'stroke-linecap':'round' });
      group.appendChild(l1); group.appendChild(l2);
    } else if(playerId === 1){
      const c = create('circle', { cx:0, cy:0, r:SIZE*0.42, fill:'none', stroke:color, 'stroke-width':6 });
      group.appendChild(c);
    } else {
      // equilateral filled triangle
      const tri = create('polygon', { points: triPoints(SIZE * 0.5), fill: color });
      group.appendChild(tri);
    }
  }

  // Click handler
  function onCellClick(q,r){
    if (!gameActive) return; // Only allow clicks if game is active

    const k = key(q,r);
    const cell = cells.get(k);
    if(!cell || cell.owner !== null) return;

    // Calculate empty cells
    const emptyCells = cells.size - moveHistory.length;

    // If only 6 empty cells left and there are moves in history, remove the oldest move
    if (emptyCells === 6 && moveHistory.length > 0) {
      const oldestMove = moveHistory.shift(); // Remove from history
      const oldestCell = cells.get(key(oldestMove.q, oldestMove.r));
      if (oldestCell) {
        oldestCell.owner = null;
        oldestCell.pieceGroup.replaceChildren(); // Remove piece visually
      }
    }

    cell.owner = currentPlayer;
    drawPiece(cell.pieceGroup, currentPlayer);
    moveHistory.push({ q, r, player: currentPlayer });
    updateMoveHistory();

    if (checkWin(q, r, currentPlayer)) {
      wins[currentPlayer]++;
      playerWinsEls[currentPlayer].textContent = wins[currentPlayer];
      statusEl.textContent = `${playerNameEls[currentPlayer].textContent} wins!`;
      gameActive = false; // Disable further moves
      return;
    }

    currentPlayer = (currentPlayer + 1) % players.length;
    setActivePlayer(currentPlayer);
  }

  function checkWin(q, r, player) {
    const directions = [
      [[1, 0], [-1, 0]], // q-axis
      [[0, 1], [0, -1]], // r-axis
      [[1, -1], [-1, 1]] // s-axis (q+r+s=0)
    ];

    const N_WIN = N; // Number of pieces in a row to win

    for (const [dir1, dir2] of directions) {
      let count = 1;
      // Check in first direction
      for (let i = 1; i < N_WIN; i++) {
        const nq = q + dir1[0] * i;
        const nr = r + dir1[1] * i;
        const cell = cells.get(key(nq, nr));
        if (cell && cell.owner === player) {
          count++;
        } else {
          break;
        }
      }
      // Check in second direction
      for (let i = 1; i < N_WIN; i++) {
        const nq = q + dir2[0] * i;
        const nr = r + dir2[1] * i;
        const cell = cells.get(key(nq, nr));
        if (cell && cell.owner === player) {
          count++;
        } else {
          break;
        }
      }

      if (count >= N_WIN) {
        return true; // Win condition met
      }
    }
    return false; // No win
  }

  // Round / Game
  function clearBoard(){
    for(const c of cells.values()){
      c.owner = null;
      c.pieceGroup.replaceChildren();
      c.g.classList.remove('win');
    }
    moveHistory = [];
    updateMoveHistory();
    gameActive = true; // Re-enable game
  }
  btnNewRound.addEventListener('click', () => {
    clearBoard();
    currentPlayer = (currentPlayer + 1) % players.length; // rotate starter
    setActivePlayer(currentPlayer);
  });
  btnNewGame.addEventListener('click', () => {
    wins = [0,0,0];
    playerWinsEls.forEach((el,i)=>el.textContent = wins[i]);
    clearBoard();
    currentPlayer = 0;
    setActivePlayer(currentPlayer);
  });

  // init
  setActivePlayer(0);
});
</script>
</body>
</html>